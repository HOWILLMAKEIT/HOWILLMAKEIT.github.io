<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构(更新中)</title>
      <link href="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>教程来源 ：油管搜索：my code school</p><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构定义：</p><p>a data structure is a way to store and organize data in a computer, </p><p>so that it can be used efficiently.</p><p>我们常说的“数据结构”其实分为两种概念：</p><p>1)ADT:  abstract data types –定义我们想要实现的功能，不讨论实现细节</p><p>2)Implementation（实现）–设计程序实现功能</p><h2 id="链表linked-list"><a href="#链表linked-list" class="headerlink" title="链表linked list"></a>链表linked list</h2><h3 id="为什么需要链表？"><a href="#为什么需要链表？" class="headerlink" title="为什么需要链表？"></a>为什么需要链表？</h3><p>在使用数组申请内存空间的时候，数组的大小往往是限定好的，例如: int A[4];这样就申请了4*4&#x3D;16个字节的空间</p><p>当你想要插入第五个元素的时候，由于这块空间附近的空间可能已经被内存管理器分配给了其他变量，这导致数组不具有扩展性。</p><p>想要扩展，只能重新创建一个数组，然后把原来的数据复制进去，由于需要遍历所有元素，因此时间复杂度为O(n)，空间复杂度也为O(n)</p><p>因此，我们需要一个<strong>更具有扩展性的数据结构</strong>——<strong>链表</strong></p><h3 id="链表的扩展性"><a href="#链表的扩展性" class="headerlink" title="链表的扩展性"></a>链表的扩展性</h3><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240709104317964.png" alt="image-20240709104317964"></p><p> 数组的特点是申请一整块连续的内存块</p><p>而链表可扩展性的秘诀在于为每一个数据申请单独的内存块（分散）</p><p>对于数组，我们可以通过内存块的首地址+数组的位置计算出某一元素所在的位置，例如数组A的首地址为200，那么A[4]就是200+4*4&#x3D;216</p><p>但是对于链表，由于内存块是分散的，如何找到对应的地址就是一个新的问题</p><p>解决方案是，在一个块中，既存放数据，又存放下一个元素（内存块）的地址</p><p>也就是说一个内存块存放两个变量，一个是<u>特定类型的元素</u>，另一个是<u>下一个元素的数据类型对应的指针</u></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240709104501024.png" alt="image-20240709104501024"></p><h3 id="节点-node"><a href="#节点-node" class="headerlink" title="节点-node"></a>节点-node</h3><p>把每一个内存块（包括元素和指针）看成一个整体，这样的整体称为：node 节点</p><p>在C&#x2F;C++中，用结构体<strong>struct</strong>定义这样一个节点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 存储数据  4字节</span></span><br><span class="line">    Node* next; <span class="comment">// 指向下一个节点的指针  4字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这里的指针类型为 Node* ，表明这里存放的是下一个节点的地址</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240709110040745.png" alt="image-20240709110040745"></p><h3 id="时间-空间复杂度"><a href="#时间-空间复杂度" class="headerlink" title="时间&#x2F;空间复杂度"></a>时间&#x2F;空间复杂度</h3><p>1、在链表中，插入一个数据需要创建节点-找到插入的位置-连接</p><p>因此对应的时间复杂度为O(n），空间复杂度为O(1)</p><p>2、删除数据需要找到删除的位置-删除节点-<a href>重新连接</a></p><p>因此对应的时间复杂度为O(n），空间复杂度为O(1)</p><h3 id="C-实现-单向链表"><a href="#C-实现-单向链表" class="headerlink" title="C++实现-单向链表"></a>C++实现-单向链表</h3><p>单向链表：single linked list </p><h4 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> * head;<span class="comment">//全局变量或者写在main函数里面都可以</span></span><br></pre></td></tr></table></figure><p>接口：</p><h4 id="1、从头-尾插入"><a href="#1、从头-尾插入" class="headerlink" title="1、从头&#x2F;尾插入"></a>1、从头&#x2F;尾插入</h4><p>注意节点必须创建在堆区，如果创建在栈区，会在函数调用借结束后释放内存。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span> <span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Node *temp = <span class="keyword">new</span> <span class="built_in">Node</span>();<span class="comment">//创建节点</span></span><br><span class="line">    temp-&gt;data = x;</span><br><span class="line">    temp-&gt;next = head;<span class="comment">//连接</span></span><br><span class="line">    head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert_end</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;</span><br><span class="line">    Node * new_node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    new_node-&gt;data= x;</span><br><span class="line">    new_node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="comment">//定位    </span></span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next=new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在任意位置插入"><a href="#2、在任意位置插入" class="headerlink" title="2、在任意位置插入"></a>2、在任意位置插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    Node* new_node =<span class="keyword">new</span> <span class="built_in">Node</span>(); </span><br><span class="line">    new_node-&gt;data = x;</span><br><span class="line">    new_node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//在这里1代表初始位置</span></span><br><span class="line">    <span class="keyword">if</span>( index == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        new_node-&gt;next = head;</span><br><span class="line">        head = new_node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位    </span></span><br><span class="line">    Node *temp= head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( temp != <span class="literal">NULL</span>)</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置无效！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;next=temp-&gt;next;</span><br><span class="line">    temp-&gt;next=new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、输出链表"><a href="#3、输出链表" class="headerlink" title="3、输出链表"></a>3、输出链表</h4><p>a.迭代方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的head是局部变量的head，不是全局变量，所以不会影响全局变量head</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">( Node * head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;head-&gt;data&lt;&lt;  <span class="string">&quot; -&gt; &quot;</span>   &lt;&lt;endl;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.递归方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归方式输出链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( Node * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">// 退出条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;-&gt; &quot;</span>;</span><br><span class="line">    <span class="built_in">Print</span>(p-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反向输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( Node * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">// 退出条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Print</span>(p-&gt;next);</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&lt;- &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在任意位置删除节点"><a href="#4、在任意位置删除节点" class="headerlink" title="4、在任意位置删除节点"></a>4、在任意位置删除节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">( <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="comment">//如果要删去开头节点</span></span><br><span class="line">    <span class="keyword">if</span> ( index == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定位到前一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; index<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置无效！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * temp1 = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp1-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、链表反转"><a href="#5、链表反转" class="headerlink" title="5、链表反转"></a>5、链表反转</h4><p>a.迭代方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node ** 是因为要传入的是 &amp;head</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(Node ** head)</span></span>&#123;</span><br><span class="line">    Node* prev = <span class="literal">NULL</span>;</span><br><span class="line">    Node* current = *head;</span><br><span class="line">    Node* next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 保存下一个节点</span></span><br><span class="line">        current-&gt;next = prev; <span class="comment">// 反转当前节点的指针</span></span><br><span class="line">        prev = current;       <span class="comment">// 移动 prev 到当前节点</span></span><br><span class="line">        current = next;       <span class="comment">// 移动 current 到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *head = prev; <span class="comment">// 更新头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.递归方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的head是全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">REverse</span><span class="params">(Node  * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">REverse</span>( p-&gt;next );</span><br><span class="line">    p-&gt;next-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如head是局部变量</span></span><br><span class="line"><span class="comment">//REverse函数需要返回第一个节点的地址</span></span><br><span class="line"><span class="function">Node* <span class="title">REverse</span> <span class="params">( Node * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * head = <span class="built_in">REverse</span>( p-&gt;next );</span><br><span class="line">    p-&gt;next-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现-双向链表"><a href="#C-实现-双向链表" class="headerlink" title="C++实现-双向链表"></a>C++实现-双向链表</h3><p>doubly linked list</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240712172237302.png" alt="image-20240712172237302"></p><h4 id="定义节点-1"><a href="#定义节点-1" class="headerlink" title="定义节点"></a>定义节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">    Node * prev;<span class="comment">// previous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、从头-尾插入-1"><a href="#1、从头-尾插入-1" class="headerlink" title="1、从头&#x2F;尾插入"></a>1、从头&#x2F;尾插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertAtHead</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node * temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        head=temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    head-&gt;prev=temp;</span><br><span class="line">    head=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertAtTail</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Node * NewNode = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    NewNode-&gt;data=x;</span><br><span class="line">    NewNode-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    NewNode-&gt;prev=temp;</span><br><span class="line">    temp-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在任意位置插入-1"><a href="#2、在任意位置插入-1" class="headerlink" title="2、在任意位置插入"></a>2、在任意位置插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReversePrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;&lt;-&gt;&quot;</span>;</span><br><span class="line">        temp=temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    Node * NewNode = <span class="keyword">new</span> <span class="built_in">Node</span>( );</span><br><span class="line">    NewNode-&gt;data = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">1</span>)&#123;<span class="comment">//从头插入</span></span><br><span class="line">        NewNode-&gt;next=head;</span><br><span class="line">        head-&gt;prev=NewNode;</span><br><span class="line">        head=NewNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * temp= head;</span><br><span class="line">    <span class="comment">//定位到目标位置前一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置无效&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * NextNode = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;next=NextNode;</span><br><span class="line">    <span class="keyword">if</span>(NextNode != <span class="literal">NULL</span>)</span><br><span class="line">    NextNode-&gt;prev=NewNode;</span><br><span class="line">    temp-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、输出链表-1"><a href="#3、输出链表-1" class="headerlink" title="3、输出链表"></a>3、输出链表</h4><p>迭代方式和递归方式的实现和单链表相同，不再赘述</p><p>反向输出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReversePrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;&lt;-&gt;&quot;</span>;</span><br><span class="line">        temp=temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717121055963.png" alt="image-20240717121055963"></p><p>只能访问栈顶,**last-in-first-out(LIFO)**最后加入的元素最先出去</p><p>定义：a list with the restriction that insertion and deletion can be performed only from one end , called the top.</p><p>operations:</p><p>Push(添加元素)、Pop(移出元素)、Top（返回栈顶的元素）、IsEmpty()这些操作的时间复杂度都是O(1) </p><p><u>在很多软件中，ctrl+z撤回的操作就是用栈来实现的</u></p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 101</span></span><br><span class="line"><span class="type">int</span> A[MAX_SIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( top == MAX_SIZE<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: stack overflow&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// top++;</span></span><br><span class="line">    <span class="comment">// A[top]=x;</span></span><br><span class="line">    A[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: No element to pop&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: No element&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>如果采用<u>动态数组</u>（当数组满了以后创建一个大小为原来的两倍的数组）</p><p>一次push的最好时间复杂度为O(1),最差为O(n)</p><p>n次push的时间复杂度为O(n),平均每次为O(1)</p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><p>相比数组实现，链表实现不需要考虑oveflow(溢出)的问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;;</span><br><span class="line">Node* top = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Node * temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;next=top;</span><br><span class="line">    top = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Stack is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * temp;</span><br><span class="line">    temp = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopElement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Stack is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h4><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717143514898.png" alt="image-20240717143514898"></p><p>在C++的标准库STL（standard template library)中已经有一个stack库</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span><span class="comment">//stack 库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数的时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//函数的空间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">char</span> C[],<span class="type">int</span> n )</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; S;<span class="comment">//创建一个char类型的栈S</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(C[i]);</span><br><span class="line">    &#125;<span class="comment">//时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;<span class="comment">//时间复杂度O(n)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> C[<span class="number">51</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter a string:  &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(C,<span class="number">51</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">strlen</span>(C);</span><br><span class="line">    <span class="built_in">Reverse</span>(C,<span class="built_in">strlen</span>(C));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在反转字符的时候，这并不是最好的算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">char</span> C[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="type">char</span> temp = C[i];</span><br><span class="line">        C[i]= C[j];</span><br><span class="line">        C[j]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> C[<span class="number">51</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter a string:  &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(C,<span class="number">51</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">strlen</span>(C);</span><br><span class="line">    <span class="built_in">Reverse</span>(C,<span class="built_in">strlen</span>(C));</span><br><span class="line">    cout&lt;&lt;C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度为O(n)空间复杂度为O(1);</p><h4 id="2、反转链表"><a href="#2、反转链表" class="headerlink" title="2、反转链表"></a>2、反转链表</h4><p>实际上，使用递归的方法反转一个链表就使用了隐式的栈(implicit stack)</p><p>下面是使用显式的栈反转链表的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( head == <span class="literal">NULL</span> )<span class="keyword">return</span>;</span><br><span class="line">    stack&lt;Node*&gt; S;<span class="comment">//构建栈</span></span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(temp);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = S.<span class="built_in">top</span>();</span><br><span class="line">    head = temp;</span><br><span class="line">    S.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp-&gt;next = S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、检查括号匹配性"><a href="#3、检查括号匹配性" class="headerlink" title="3、检查括号匹配性"></a>3、检查括号匹配性</h4><p>记得有一次上机测试我用计算规定当出现（时候+1，当出现）时候-1，同时限制数字之和不为负数【防止出现“)(”的情况】这种方法解出了题目</p><p>但是我的这种方法无法判定（【）】这种式子是否正确</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717211428517.png" alt="image-20240717211428517"></p><p>那么，如何解决这个问题呢？</p><p>把左括号逐个丢入栈中，每次遇到右括号，都先判断一下其与相邻的括号是否配对，如果配对，就将相邻的括号pop掉（有点像消消乐），如果不配对，说明括号不配对</p><p>这里运用到了<strong>last in firtst out</strong> 的思想，具体表现为<strong>最后进入的最早闭合</strong></p><p>有的编译器&#x2F;编辑器（如vscode）可以检测出代码括号不配对这种错误，其实就是用栈实现的</p><p>具体实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBalanceParenthesis</span><span class="params">(<span class="type">char</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(A);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == <span class="string">&#x27;[&#x27;</span>||A[i] == <span class="string">&#x27;(&#x27;</span> || A[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(A[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || s.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || s.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || s.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main函数（测试用）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> A[<span class="number">10</span>];</span><br><span class="line">        cin.<span class="built_in">getline</span>(A,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">CheckBalanceParenthesis</span>(A))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;括号配对&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;括号不配对&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀、中缀、后缀"><a href="#前缀、中缀、后缀" class="headerlink" title="前缀、中缀、后缀"></a>前缀、中缀、后缀</h3><p>prefix infix postfix</p><p>操作数：operand</p><p>操作符：operator</p><p>对于一个表达式，我们可以有中缀表达式、前缀表达式、后缀表达式</p><p>它们的含义是相同的，我们日常中使用比较频繁的是中缀表达式</p><p>但是，中缀表达式存在歧义问题，例如3+5*2的计算，是通过规定 * 的优先级在+之上才有了唯一的结果，除此之外，中缀表达式还通过规定括号的优先级，多个连续的幂运算的优先级来避免歧义</p><p>而逻辑学家和数学家则找到了<strong>能够有效避免歧义的表示方法</strong>，即前缀表达式(波兰表达式)和后缀表达式(逆波兰表达式 )，这两种表达式<strong>不需要规定运算符的优先级和结合性，更不用使用括号</strong></p><p>从编程的角度而言，后缀表达式是<u>最容易解析、求值的时间和内存代价最小</u>的</p><p>中缀表达式不需要空格，但后缀和前缀表达式需要空格区分，例如2333*意义不明，22 33 * 和 223 3 *则明确</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717220508557.png" alt="image-20240717220508557"></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240718095209122.png" alt="image-20240718095209122"></p><h4 id="后缀表达式的计算："><a href="#后缀表达式的计算：" class="headerlink" title="后缀表达式的计算："></a>后缀表达式的计算：</h4><p>注意到这些运算符都是二元运算符，每个运算符要找到它的两个操作数（<strong>从左往右</strong>）</p><p>例如：2 3 * 5 4 * + 9 - ， 第一个* 的操作数是2 3 ，第二个为 5 和 4，即化为 6 20 + 9 -，+的操作数为6 20 即：26 9 - ，-的操作数为 26 9，即17</p><p><strong>这个计算过程可以用栈很好地进行</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EvaluatePostfix</span><span class="params">(<span class="type">char</span> A[])</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; A[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(A[i])) &#123;</span><br><span class="line">            numStr += A[i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!numStr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">//例如当出现 23 5...的时候，push的是23而不是2和3</span></span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(numStr));</span><br><span class="line">                    numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> op2=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> op1=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(A[i])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1+op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1-op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1*op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1/op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span> (!numStr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(numStr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前缀表达式的计算同理</p><p>用代码计算前缀表达式的时候，其实只需要改动一步：从后往前遍历，这样就可以像计算后缀表达式一样利用栈来计算了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从后向前遍历字符数组 A</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(A) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; A[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            numStr += A[i];</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><h4 id="表达式的转换"><a href="#表达式的转换" class="headerlink" title="表达式的转换"></a>表达式的转换</h4><p>中缀-&gt;后缀</p><p>注意到中缀转后缀的过程中，操作符的次序可能变化，但是操作数的次序不变</p><p>因此读取到操作数时，可以直接将其放入表达式中</p><p>那么如何确定运算符的次序呢？</p><p>有一种算法是：</p><p>当新的操作符的优先级比栈顶操作符的优先级高时，压入栈</p><p>反之，栈顶元素弹出，直到将新元素压入栈为止</p><p>括号处理：（直接压入栈中，出现），就使栈顶元素弹出，直到”（“弹出，注意弹出的（不需要加入表达式中。</p><p>在这个过程中，如果遇到操作数，直接加入表达式即可，同时最后如果栈中还有操作符，依次弹出即可</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240718150806487.png" alt="image-20240718150806487"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">precedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">InfixToPostfix</span><span class="params">(string infix)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operators;</span><br><span class="line">    string postfix = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; infix.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = infix[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            <span class="comment">// 将多位数作为一个整体处理</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; infix.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(infix[i])) &#123;</span><br><span class="line">                postfix += infix[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// 回退一步，因为外层循环还会再增加一次</span></span><br><span class="line">            postfix += <span class="string">&#x27; &#x27;</span>; <span class="comment">// 在数字后面添加空格，以分隔数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正常情况下中缀表达式不需要使用括号，出现了就忽略即可 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operators.<span class="built_in">empty</span>() &amp;&amp; operators.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfix += operators.<span class="built_in">top</span>();</span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">pop</span>(); <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新操作符的优先级小于等于栈顶操作符-&gt;栈顶弹出</span></span><br><span class="line">            <span class="comment">//新操作符的优先级大于栈顶操作符    -&gt;压入</span></span><br><span class="line">            <span class="keyword">while</span> (!operators.<span class="built_in">empty</span>() &amp;&amp; operators.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; <span class="built_in">precedence</span>(c) &lt;= <span class="built_in">precedence</span>(operators.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                postfix += operators.<span class="built_in">top</span>();</span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operators.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        postfix += operators.<span class="built_in">top</span>();</span><br><span class="line">        operators.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postfix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中缀-&gt;前缀</p><p>具体流程和上文中缀-&gt;后缀的算法类似，只需要保证在弹出操作符的时候，将操作符加在表达式的最前方</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">InfixToPrefix</span><span class="params">(string infix)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;operators;</span><br><span class="line">    string prefix = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;infix.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = infix[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;infix.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(infix[i]))&#123;</span><br><span class="line">                prefix +=infix[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">//单引号，因为要添加是字符不是字符串</span></span><br><span class="line">            prefix +=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(operators.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span> &amp;&amp; !operators.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                prefix = operators.<span class="built_in">top</span>()+prefix;<span class="comment">//接在前面</span></span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//弹出直到能够压入</span></span><br><span class="line">            <span class="keyword">while</span>(!operators.<span class="built_in">empty</span>()&amp;&amp; <span class="built_in">precedence</span>(operators.<span class="built_in">top</span>())&gt;=<span class="built_in">precedence</span>(c))&#123;</span><br><span class="line">                prefix = operators.<span class="built_in">top</span>()+prefix;<span class="comment">//接在前面</span></span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!operators.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        prefix = operators.<span class="built_in">top</span>()+prefix;<span class="comment">//接在前面</span></span><br><span class="line">        operators.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列Queues"><a href="#队列Queues" class="headerlink" title="队列Queues"></a>队列Queues</h2><h3 id="ADT-1"><a href="#ADT-1" class="headerlink" title="ADT"></a>ADT</h3><p>First-In-First-Out</p><p>定义：A list or collection with the restriction that isertion can be performed at one end (rear) and deletion can be performed at other end (front)</p><p>队尾进，队头出</p><p>operations:</p><p>EnQueue&#x2F;push :从队尾插入元素</p><p>DeQueue&#x2F;pop : 从队首移出元素</p><p>front&#x2F;peek: 返回队首元素</p><p>IsEmpty：查看是否为空</p><p>时间复杂度都是O（1）</p><p><u>栈是一段开口的容器，队列就是两端开口的容器</u></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719090231956.png" alt="image-20240719090231956"></p><p>下面将给出两种简单的实现方式</p><p>ps：C++标准库中的<code>queue</code>模板类通常使用双端队列（<code>deque</code>）作为其底层容器，而不是数组或链表。</p><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><p>规定一个数组的某一边为front，另一边为rear</p><p>用变量记录这两个位置的索引，黄色的范围就是队列的范围，其他部分备用</p><p>用数组实现队列有一个有趣的现象，如果规定左侧为front，右侧为rear，可以发现队列会一直向右侧移动</p><p>如果想要最大化使用数组的内存，可以利用<strong>循环数组</strong>的概念</p><p>此时current position &#x3D; i, next position &#x3D;(i+1)%N, prv position &#x3D; (i+N-1)%N,这样一直增加i，就可以不断循环遍历数组的每一个位置，如果使用<strong>循环数组</strong>，那么队列满的条件是：</p><p>(rear+1)%N&#x3D;front，即使rear的下一位就是front</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719104359815.png" alt="image-20240719104359815"></p><p>以下代码没有使用循环数组</p><p>但是利用了动态数组，在队列满了以后，会创建一个两倍原大小的新数组用于存放队列</p><p>使用先需要先调用init 函数进行初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queues</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> * A;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> front =<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> rear  =<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="type">int</span>[x];</span><br><span class="line">        size = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            front = rear = <span class="number">0</span>;</span><br><span class="line">            A[rear] = x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//满</span></span><br><span class="line">        <span class="keyword">if</span> (rear == size) &#123;</span><br><span class="line">            <span class="built_in">QueueIsFull</span>();</span><br><span class="line">            rear++;</span><br><span class="line">            A[rear] = x;</span><br><span class="line">            <span class="keyword">return</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        A[rear] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            front = rear = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放回队首元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[rear];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理数组满了的情况</span></span><br><span class="line">    <span class="comment">//无需手动调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">QueueIsFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最坏的情况是原数组的所有位置都填满了</span></span><br><span class="line">        <span class="type">int</span> newSize = <span class="number">2</span> * (size);</span><br><span class="line">        <span class="type">int</span>* B = <span class="keyword">new</span> <span class="type">int</span>[newSize];</span><br><span class="line">        <span class="type">int</span> temp = front;</span><br><span class="line">        <span class="type">int</span> lengh = rear - front;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lengh; i++) &#123;</span><br><span class="line">            B[i] = A[temp];</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        A = B;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = lengh;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= rear; i++) &#123;</span><br><span class="line">            cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queues q1;</span><br><span class="line">    q1.<span class="built_in">init</span>(<span class="number">5</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    q1.<span class="built_in">pop</span>();</span><br><span class="line">    q1.<span class="built_in">Print</span>();<span class="comment">// 2 3 4 5 </span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">121</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">50000</span>);<span class="comment">//满了</span></span><br><span class="line">    q1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="comment">//2 3 4 5 121 50000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><p>正常的链表只需要一个head记录头节点的地址就可以</p><p>这里需要再加上一个rear指针记录最后一个节点的地址</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719131429378.png" alt="image-20240719131429378"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queues</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node * next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* front = <span class="literal">NULL</span>;</span><br><span class="line">    Node * rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        Node * temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        temp-&gt;data = x;</span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span> &amp;&amp; rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            front = rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队尾进</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rear-&gt;next = temp;</span><br><span class="line">            rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队头出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(front == rear)&#123;</span><br><span class="line">            <span class="keyword">delete</span> front;</span><br><span class="line">            front = rear = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node * temp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Error: queues is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> front-&gt;data; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Error: queues is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> rear-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node * temp = front;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树tree"><a href="#树tree" class="headerlink" title="树tree"></a>树tree</h2><h3 id="ADT-2"><a href="#ADT-2" class="headerlink" title="ADT"></a>ADT</h3><p>是一种层级结构（非线性）</p><p>是多个节点的集合，最高的节点称之为<strong>根</strong>（root）</p><p>各节点的关系：</p><p><strong>parent</strong> <strong>children</strong> <strong>sibling</strong><strong>ancenstor</strong>(例如节点1是所有节点的祖先) <strong>descendent</strong> <strong>cousin</strong></p><p>没有子节点的节点称为<strong>叶</strong>（leaf）</p><p>N个节点的树，有N-1条边（edge）因为每个节点（除了root）都只有一条传入的边</p><p><strong>depth</strong>：length of path from root to x 例如节点5的深度为2</p><p><strong>层级</strong>：深度为2，可以称为level-2(L-2），root 为level-0（L-2）</p><p><strong>Height</strong>：No. of edges in longest path from x to a leaf例如节点3的高度是2，leaf的高度是0</p><p>height of tree：就是root的height，下面这棵树的高度是3</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719134607138.png" alt="image-20240719134607138"></p><p><strong>Binary Tree</strong>：树中的每个节点至多有两条传出的边</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node * left;</span><br><span class="line">Node * right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719135927990.png" alt="image-20240719135927990"></p><p>应用：</p><p>1)天然具备层级的数据，例如磁盘驱动器的文件系统</p><p>2)快速查找、插入、删除</p><p>3)动态的拼写检查</p><p>4)网络路由算法</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>每个节点最多有两个孩子，一个称为left-child 另一个称为right-child</p><p>严格二叉树strict&#x2F;proper binary tree：每个节点要么有两个孩子，要么有0个孩子</p><p>完全二叉树Complete Binary tree: 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。（满二叉树perfect Binary tree是特殊的完全二叉树）</p><p>第i层的最大节点数为2^i, 总最大节点数为2^(h+1)-1,其中h是二叉树的深度&#x2F;高度</p><p>换句话说,深度 h&#x3D;log2 (n+1)-1 &#x3D; log2 n 向下取整</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乌萨奇通讯录项目报告</title>
      <link href="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/"/>
      <url>/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/</url>
      
        <content type="html"><![CDATA[<h1 id="乌萨奇通讯录项目报告"><a href="#乌萨奇通讯录项目报告" class="headerlink" title="乌萨奇通讯录项目报告"></a>乌萨奇通讯录项目报告</h1><h2 id="设计背景："><a href="#设计背景：" class="headerlink" title="设计背景："></a><strong>设计背景：</strong></h2><p>在聊天软件（如微信）日益发达的今天，我们通过打电话联系他人的频率越来越低，这导致了我们可能会经常性地忘记某个朋友的电话或是邮箱账号。</p><p>在移动端已经有了成熟的通讯录app的基础上，乌萨奇通讯录的设计目的是在PC端为用户提供方便快捷的录入联系人信息的功能，以及强大的生日查询和邮件发送功能，满足现代人日益发展的社交需求。</p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a><strong>程序结构</strong></h2><p>本项目共有17个.h头文件，对应17个.cpp头文件以及14个.ui文件，由于界面文件较多，下面由界面的切换逻辑来对程序的结构进行讲解。</p><p>界面切换逻辑示意图：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103858409.png" alt="image-20240617103858409"></p><p>图中，带有“切换“字样的双箭头表明两个界面之间是来回切换的关系，但一个页面显示，另一个页面则会进行隐藏。</p><p>而单箭头表明从箭头的起点对应的页面可以产生箭头指向的页面，两个页面将会同时显示在屏幕上。</p><p>而从Email_func到Email_func_birth、Email_func_normal、Email_send_func的切换逻辑比较特殊，这里在Email_func页面制作了一个侧边栏的设计，可以通过三个按钮在三个页面间来回切换。</p><p>除了图中14个包含.ui文件的文件，本项目中还有四个文件，他们的功能如下：</p><p>|——mysound.h &#x2F;&#x2F;实现各种音效</p><p>|——contact.h &#x2F;&#x2F;包含一个基类和五个派生类，实现快速添加联系人</p><p>|——db_operator.h &#x2F;&#x2F;连接数据库</p><p>|——email.h &#x2F;&#x2F;封装一个函数，用于发送邮件</p><h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a><strong>程序功能</strong></h2><p>下面我将结合相应的界面对项目的功能进行说明，并会对该功能的实现方式进行简单的诠释。</p><p>主界面如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103921604.png" alt="image-20240617103921604"></p><h3 id="1、登录-注册功能："><a href="#1、登录-注册功能：" class="headerlink" title="1、登录&#x2F;注册功能："></a><strong>1、登录&#x2F;注册功能：</strong></h3><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103933469.png" alt="image-20240617103933469"></p><p>用户打开程序，最先显示的是左侧的登录界面，首先用户应该注册一个账户，注册界面如右图所示。</p><p>用户可以自由添加头像，图片中显示的是用户的默认头像，接着用户可以输入自己的用户名和密码（密码需要二次输入进行确认），点击“注册”后，程序会将用户的用户名和密码信息保存到数据库中，实现注册功能。</p><p>在具体的代码中，首先用</p><p>QString username &#x3D; ui-&gt;username_le-&gt;text();</p><p>QString pwd_1 &#x3D; ui-&gt;pwd_le1-&gt;text();</p><p>QString pwd_2 &#x3D; ui-&gt;pwd_le2-&gt;text();</p><p>获取用户输入的信息，接着用if语句用户输入是否为空以及两次输入的密码是否相同等内容。</p><p>重要的是会对数据库中是否已存在相同的用户名进行判定，判定代码如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103948169.png" alt="image-20240617103948169"></p><p>若查询结果为空，表明不存在相同的用户名，下一步会进行图片的处理。</p><p>此处限定图片大小为15.9mb是因为数据库中用于存放图片数据的字段的数据类型为MEDIUNBLOB，其最大容量为15.9mb</p><p>此过程可以概括为将图片的二进制数据写入QByteArray 对象 photo_data后，用photo_data初始化QVariant对象 photo</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图片处理</span></span><br><span class="line">              QByteArray photo_data;</span><br><span class="line">              <span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;photo_data)</span></span>;</span><br><span class="line">              buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">              <span class="keyword">this</span>-&gt;image.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;JPEG&quot;</span>,<span class="number">100</span>); <span class="comment">// 将图片的二进制数据写入photo_data</span></span><br><span class="line">              <span class="comment">// 检查图片数据大小</span></span><br><span class="line">              <span class="type">int</span> quality=<span class="number">90</span>;</span><br><span class="line">              <span class="keyword">while</span> (photo_data.<span class="built_in">size</span>() &gt; <span class="number">15.9</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">// 图片数据超过了最大允许大小</span></span><br><span class="line">                  <span class="comment">// 清空buffer</span></span><br><span class="line">                  buffer.<span class="built_in">setData</span>(<span class="built_in">QByteArray</span>());</span><br><span class="line">                  <span class="comment">// 重新保存 quality  逐渐降低</span></span><br><span class="line">                  image.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;JPEG&quot;</span>,quality);</span><br><span class="line">                  <span class="built_in">qDebug</span>()&lt;&lt; quality ;</span><br><span class="line">                  quality -= <span class="number">10</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="function">QVariant <span class="title">photo</span><span class="params">(photo_data)</span></span>;</span><br></pre></td></tr></table></figure><p>在获取了用户的信息后，对用户信息进行插入操作，对应代码如下：c</p><p>（此处的memo字段用于存放“便利贴”中的内容，在之后的“便利贴”功能讲解中会说明，这里先插入一个空字符串）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">QString memo  = <span class="string">&quot;&quot;</span>;</span><br><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO accounts (user_name, password, photo,memo) VALUES (:username, :password,:photo,:memo)&quot;</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:username&quot;</span>, username);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:password&quot;</span>, pwd_1);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:photo&quot;</span>, photo);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:memo&quot;</span>, memo);</span><br><span class="line"><span class="keyword">if</span> (query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    sound.yaha.<span class="built_in">play</span>();</span><br><span class="line">    QMessageBox::<span class="built_in">information</span> (<span class="keyword">this</span>, <span class="string">&quot;注册&quot;</span>, <span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">    <span class="function">emit <span class="title">regist_ready</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注册成功后，用户便能够进行登录操作</p><p>点击登录按钮对应的槽函数的部分代码如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104017986.png" alt="image-20240617104017986">这段代码在数据库中查询是否存在对应用户名和密码的数据，接着将数据库中accounts表中的id（primary key)存储到变量user_id中。</p><h3 id="2、添加-修改-删除联系人信息功能"><a href="#2、添加-修改-删除联系人信息功能" class="headerlink" title="2、添加&#x2F;修改&#x2F;删除联系人信息功能"></a><strong>2、添加&#x2F;修改&#x2F;删除联系人信息功能</strong></h3><p>添加页面：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104043299.png" alt="image-20240617104043299"></p><p>添加页面的comboBox提供了四个默认分组以及“无”和“其他”的选项</p><p>如果选择“其他”就会让用户填写自定义的分组。</p><p>这个小功能的实现是利用了on_comboBox_activated这一个槽函数，这个槽函数会在comboBox的索引被修改的时候自动调用，当索引为5（对应“其他”）的时候ui-&gt;newtype_lb-&gt;setVisible(true);ui-&gt;newtype_le-&gt;setVisible(true)；</p><p>点击“添加联系人”按钮以后，在槽函数中，会执行对用户输入内容的检测、图片处理等，这一部分和上文登录&#x2F;注册功能中展示的代码类似，不再进行展示。</p><p>随后，利用switch语句，根据用户在comboBox中选择的索引，进行对应对象的创建，其中new_contact是Contact*类型对象，其他类均为Contact类的子类</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104052407.png" alt="image-20240617104052407"></p><p>Other_cot类的add_contact函数实现如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104102613.png" alt="image-20240617104102613"></p><p>这样就实现了联系人信息的添加。</p><p>添加成功后，关闭页面，就可以看到新添加的联系人已经出现在了主界面上，这里重写了add_func类的关闭事件</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104110431.png" alt="image-20240617104110431"></p><p>关闭页面后发出close（）信号，其与main_func对象的on_show()槽函数连接</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104205576.png" alt="image-20240617104205576"></p><p>其中show_cot代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">   query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT name, birth, phone, email, type, special_info FROM contacts WHERE user_id = :user_id&quot;</span>);</span><br><span class="line">   query.<span class="built_in">bindValue</span>(<span class="string">&quot;:user_id&quot;</span>, <span class="keyword">this</span>-&gt;user_id);</span><br><span class="line">   query.<span class="built_in">exec</span>();</span><br><span class="line">   <span class="comment">//qDebug()&lt;&lt; this-&gt;user_id;</span></span><br><span class="line">   <span class="keyword">this</span>-&gt;qmodel = <span class="keyword">new</span> <span class="built_in">QSqlQueryModel</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//使用移动语义设置模型的数据</span></span><br><span class="line">   qmodel-&gt;<span class="built_in">setQuery</span>(std::<span class="built_in">move</span>(query));</span><br><span class="line">   <span class="comment">//ui-&gt;contact_table-&gt;setModel(qmodel);</span></span><br><span class="line"></span><br><span class="line">   ui-&gt;contact_table-&gt;<span class="built_in">setSortingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   QSortFilterProxyModel *sqlproxy = <span class="keyword">new</span> <span class="built_in">QSortFilterProxyModel</span>(<span class="keyword">this</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setSourceModel</span>(qmodel);</span><br><span class="line"></span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;生日&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">2</span>, Qt::Horizontal, <span class="string">&quot;电话号码&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">3</span>, Qt::Horizontal, <span class="string">&quot;邮箱&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">4</span>, Qt::Horizontal, <span class="string">&quot;分组&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">5</span>, Qt::Horizontal, <span class="string">&quot;备注&quot;</span>);</span><br><span class="line"></span><br><span class="line">   ui-&gt;contact_table-&gt;<span class="built_in">setModel</span>(sqlproxy);</span><br></pre></td></tr></table></figure><p>这样就实现了页面切换+自动刷新，之后的页面切换功能都是采用类似的做法，不会再次讲解。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104521061.png" alt="image-20240617104521061"></p><p>在主界面，可以右键呼出菜单项，点击“查看”后，跳转到查看页面</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104527764.png" alt="image-20240617104527764"></p><p>在查看页面中，可以对输入框的内容进行修改，点击保存按钮后，即修改成功，保存按钮的槽函数和上文添加联系人功能的槽函数类似，都是检验格式+图片处理，只是第三步修改为了update语句，例如：UPDATE contacts SET name &#x3D; :name_change</p><p>这里不作详细展示。</p><p>有关利用菜单项切换页面的具体实现，会在“技术亮点”中进行讲解</p><p>删除功能：</p><p>实现流程是，根据索引值和model信息，获取鼠标点击位置的那一行的相关数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Modify_func::data_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> row = index.<span class="built_in">row</span>();</span><br><span class="line">    name = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">0</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    birth  = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">1</span>)).<span class="built_in">toDate</span>();</span><br><span class="line">    phone = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">2</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    email = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">3</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    type = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">4</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    special_info=model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">5</span>)).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着在数据库中进行查询</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT photo &quot;</span></span><br><span class="line">                  <span class="string">&quot;FROM contacts&quot;</span></span><br><span class="line">                  <span class="string">&quot; WHERE  name=:name AND  birth=:birth AND  phone=:phone AND email=:email AND type=:type AND special_info=:special_info AND user_id=:user_id &quot;</span>);</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, name);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:birth&quot;</span>,  birth);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:phone&quot;</span>,  phone);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:email&quot;</span>,  email);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:type&quot;</span>,  type);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:special_info&quot;</span>, special_info);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:user_id&quot;</span>, <span class="keyword">this</span>-&gt;user_id);</span><br><span class="line">    query.<span class="built_in">exec</span>();</span><br><span class="line">    query.<span class="built_in">next</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后提取那一行的id（主键），然后用DELETE语句进行删除</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取contacts表中这一行数据的id</span></span><br><span class="line">        <span class="type">int</span> id = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;id;</span><br><span class="line">        <span class="comment">// 删除语句</span></span><br><span class="line">        QString deleteSql = <span class="built_in">QString</span>(<span class="string">&quot;DELETE FROM contacts WHERE id = %1&quot;</span>).<span class="built_in">arg</span>(id);</span><br><span class="line">        <span class="keyword">if</span>(query.<span class="built_in">exec</span>(deleteSql))<span class="comment">//删除</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">            emit <span class="keyword">this</span>-&gt;<span class="built_in">delete_ready</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、生日查询-祝福邮件发送功能"><a href="#3、生日查询-祝福邮件发送功能" class="headerlink" title="3、生日查询&#x2F;祝福邮件发送功能"></a><strong>3、生日查询&#x2F;祝福邮件发送功能</strong></h3><p>生日查询界面如下：</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104718253.png" alt="image-20240617104718253" style="zoom: 67%;"><p>左侧是三个按钮，可以实现页面切换，这里侧边栏的实现是通过stackedWidget实现</p><p>具体而言步骤为：</p><p>1、为Email_func的stackedWidget对象添加界面对象的地址</p><p>2、为每个按钮设定索引值</p><p>3、连接信号，将点击按钮传递的信号（包含索引值）与stackedWidget的setCurrentIndex函数连接，实现页面切换</p><p>这里没有将buttonClicked信号与setCurrentIndex函数直接连接，buttonClicked会传递一个QAbstractButton *类型的参数，与setCurrentIndex需要的参数类型（int）不匹配，所以写了一个适配器函数onButtonClicked进行辅助连接。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104739982.png" alt="image-20240617104739982"></p><p>适配器函数：<img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104748716.png" alt="image-20240617104748716"></p><p>年-月-日查询：</p><p>在最上方提供了三各QspinBox用于信息的输入，每个QspinBox都设定了范围</p><p>同时0作为一个默认值，代表所有，例如用户对0-0-0进行生日查询，会查询出所有联系人</p><p>如果对0-7-0进行查询，就可以查询任意年份+7月+任意日期过生日的联系人。</p><p>这个查询功能的实现方式将会在“难点攻破”中详细说明</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104759495.png" alt="image-20240617104759495"></p><p>近期生日查询：</p><p>在此页面中，同样用一个QspinBox进行信息的输入，范围设置为0-31</p><p>可以查询当天前后0-31天过生日的联系人，具体实现会在“技术亮点”中进行讲解</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104815721.png" alt="image-20240617104815721" style="zoom:67%;"><p>邮件发送功能：</p><p>在输入框中输入收件人的邮箱（可以在前两个页面查询的结果中直接复制，十分方便）</p><p>会自动匹配邮箱名对应的联系人姓名，并且显示在上方，同时自动修改正文开头</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104832710.png" alt="image-20240617104832710"></p><p>自动匹配姓名的代码如下：</p><p>这段代码在on_lineEdit_textChanged槽函数中实现（在line_edit中的内容被更改的时候调用此函数）</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104844452.png" alt="image-20240617104844452"></p><p>点击“发送邮件”有，跳转到邮箱登录界面：</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104854364.png" alt="image-20240617104854364" style="zoom:50%;"><p>这里要求用户填写邮箱的账号以及授权码（不是密码）需要用户去发送邮件的邮箱开通POP3&#x2F;SMTP服务</p><p>开通后，会得到一个授权码。</p><p>填写好邮箱和授权码，点击“登录此邮箱”就会进行一个邮件的发送。</p><p>点击按钮后，如果输入格式正确，email_login对象会发出一个email_login信号，这个信连接的槽函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里要小心多次连接问题</span></span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> check=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(check==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">connect</span>(email_login_page,&amp;email_login::login_ready,[=]()</span><br><span class="line">               &#123;</span><br><span class="line">                   QString  SenderEmail= email_login_page-&gt;account;</span><br><span class="line">                   QString SenderPassword = email_login_page-&gt;password;</span><br><span class="line"></span><br><span class="line">                   QRegularExpression <span class="built_in">regex</span>(<span class="string">&quot;^(.+)@(.+)$&quot;</span>);</span><br><span class="line">                   QRegularExpressionMatch match = regex.<span class="built_in">match</span>(SenderEmail);</span><br><span class="line">                   QString domain = match.<span class="built_in">captured</span>(<span class="number">2</span>);</span><br><span class="line">                   QString SmtpServer = <span class="string">&quot;smtp.&quot;</span>  +  domain;</span><br><span class="line">                   <span class="built_in">qDebug</span>()&lt;&lt;SmtpServer;</span><br><span class="line">                   QString ReceiveEmail=ui-&gt;lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">                   <span class="type">int</span> SmtpPort =<span class="number">25</span>;</span><br><span class="line">                   QString SubjectTitle=<span class="string">&quot;生日快乐！&quot;</span>;</span><br><span class="line">                   QString Content=ui-&gt;plainTextEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line"></span><br><span class="line">                   email.<span class="built_in">sendEmail</span>(  SmtpServer,  SmtpPort, SenderEmail,  SenderPassword,  ReceiveEmail,  SubjectTitle,  Content);</span><br><span class="line"></span><br><span class="line">               &#125;);</span><br><span class="line">       check++;</span><br><span class="line">   &#125;</span><br><span class="line">   email_login_page-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>这里采用正则表达式获取用户邮箱的@后面内容，&lt;例如<a href="mailto:&#120;&#x78;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#x78;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>&gt;，会获取“qq.com”,接着在qq前加上smtp.前缀，就是qq的smtp服务器smtp.qq.com，端口一般时25，接着将用于发送邮件的邮箱的邮箱名、授权码、收件邮箱的邮箱名、邮件标题（这里默认为“生日快乐！”）、邮箱正文（用户之前编辑的内容）作为sendEmail函数的参数，在sendEmail函数中实现邮件发送。在sendEmail函数中，采取TCP连接方式，用一个QTcpSocket对象的write函数向服务器发送信息，用readAll函数接收服务器发送回来的信息，由于此代码长度较长，而且重复的内容较多（基本上就是依次发送上方的七个参数的内容给服务器）这里只展示一个小片段：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104932783.png" alt="image-20240617104932783"></p><h3 id="4、搜索功能："><a href="#4、搜索功能：" class="headerlink" title="4、搜索功能："></a><strong>4、搜索功能：</strong></h3><p>在主界面的上方，有一个搜索框，可以对联系人信息进行搜索：</p><p>例如这里输入“境”出现了王境博和环境专业的乌萨奇</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104942257.png" alt="image-20240617104942257"></p><p>模糊搜索功能实现代码如下：</p><p>如果输入框中没有内容，这段代码还可以是实现刷新功能</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104951215.png" alt="image-20240617104951215"></p><p>查询成功后，用query去初始化model，再用model去渲染tableview就可以显示查找结果。（上文有类似代码）</p><h3 id="5、用户信息修改功能："><a href="#5、用户信息修改功能：" class="headerlink" title="5、用户信息修改功能："></a><strong>5、用户信息修改功能：</strong></h3><p>点击用户头像会弹出来一个菜单项</p><p>“修改头像”、“注销账号”的功能与联系人的添加头像和删除类似，这里不再赘述</p><p>“修改用户名”和“修改密码”类似，这里以后者为例</p><p>点击按钮后，弹出一个修改密码界面，要求用户先输入原密码，再两次输入新密码，</p><p>如果两次输入的密码相同，就用UPDATE语句修改accounts表中id&#x3D;user_id处的password字段信息</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105005480.png" alt="image-20240617105005480"></p><p>注销账号页面如下：<br><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105013921.png" alt="image-20240617105013921" style="zoom:50%;"></p><p>退出登录功能：</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105028186.png" alt="image-20240617105028186" style="zoom: 67%;"><p>发送了一个exit_account信号，与Login类的on_show槽函数连接，退出登录后，将会返回到Login界面</p><h3 id="6、便利贴-备忘录"><a href="#6、便利贴-备忘录" class="headerlink" title="6、便利贴&#x2F;备忘录"></a><strong>6、便利贴&#x2F;备忘录</strong></h3><p>在主界面的左下角有一个便利贴功能，可以记录一下一些待办事项</p><p>便利贴（plainTextEdit）的样式设定为0.6的透明度</p><p>而一旦用户的鼠标悬停&#x2F;正在编辑plainTextEdit，就设定背景为黄色，方便用户看清内容（前文的搜索框也采用了类似的设计）</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105042851.png" alt="image-20240617105042851" style="zoom: 67%;"><p>便利贴信息存储在accounts表格的memo字段，在mainfunc的init中进行初始化，同时，在每个退出主界面的地方都设定了自动保存（例如点击头像-退出登录、直接点击页面右上角的关闭）这样就实现了自动保存，减少用户操作的繁琐性。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105101040.png" alt="image-20240617105101040"></p><h3 id="7、音效"><a href="#7、音效" class="headerlink" title="7、音效"></a><strong>7、音效</strong></h3><p>在MySound类中，有五个QSoundEffect成员变量，在构造函数进行初始化后，只需要在对应位置用QSoundEffect对象的.play()函数就可以实现音效的播放</p><p>MySound类的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySound::<span class="built_in">MySound</span>(QObject *parent)</span><br><span class="line">    : QObject&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line">    ha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/ha.wav&quot;</span>));</span><br><span class="line">    ha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);  <span class="comment">//循环次数</span></span><br><span class="line">    ha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>); <span class="comment">//音量  0~1之间</span></span><br><span class="line"></span><br><span class="line">    highest_yaha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/highest_yaha.wav&quot;</span>));</span><br><span class="line">    highest_yaha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    highest_yaha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    yaha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/yaha.wav&quot;</span>));</span><br><span class="line">    yaha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    yaha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    wula.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/wuda.wav&quot;</span>));</span><br><span class="line">    wula.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    wula.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    wulayaha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/wulayahayahawula.wav&quot;</span>));</span><br><span class="line">    wulayaha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    wulayaha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a><strong>技术亮点</strong></h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a><strong>数据库设计</strong></h3><p>accounts表设计</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105411435.png" alt="image-20240617105411435"></p><p>contacts表设计：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105418807.png" alt="image-20240617105418807"></p><p>本数据库设计的亮点在于将accounts表的id字段（主键）设定为了 contacts表中user_id字段的外键，同时将On Update和On Delete都设定为了CASCADE,保证了数据的同步。</p><p>通过这样的方式，每一个联系人都用一个user_id字段表明这个联系人属于哪一个特定的用户，即便将所有联系人数据存储在一张表格中，也不会导致混乱。</p><h3 id="云端数据库"><a href="#云端数据库" class="headerlink" title="云端数据库"></a><strong>云端数据库</strong></h3><p>本项目将数据库建立在阿里云的RDS数据库，解决了最终.exe程序的连接问题，使得程序真正成为一个可独立运行的软件。</p><p>无论在什么地方，采用什么设备，只要能够正常联网，用户就可以查询到自己账户里的联系人信息。</p><p>部分用户展示（表明程序可正常运行）</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105450395.png" alt="image-20240617105450395"></p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105457358.png" alt="image-20240617105457358"></p><h3 id="右键菜单的实现："><a href="#右键菜单的实现：" class="headerlink" title="右键菜单的实现："></a><strong>右键菜单的实现：</strong></h3><p>本项目在头像处和主界面TableView处都使用了右键菜单，这里以主界面的实现方式进行讲解：</p><p>在Mainfunc的set_Menu函数中，首先调用QTableView的setContextMenuPolicy(Qt::CustomContextMenu)函数</p><p>使右键能够发送customContextMenuRequested信号</p><p>接着为QMenu对象添加两个QAction对象，然后将customContextMenuRequested信号与槽函数Menu_Slot连接</p><p>以及将两个QAction对象triggered信号与Modify_func对象中对应的对应槽函数连接（这两个槽函数在上文进行过讲解）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mainfunc::set_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//右键发送customContextMenuRequested 信号</span></span><br><span class="line">    ui-&gt;contact_table-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line">    <span class="keyword">this</span>-&gt;tableviewMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>( ui-&gt;contact_table); <span class="comment">// menu的父类是tableview 对象</span></span><br><span class="line"></span><br><span class="line">    Action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;查看&quot;</span>, ui-&gt;contact_table);</span><br><span class="line">    Action2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;删除&quot;</span>, ui-&gt;contact_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单项</span></span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">addAction</span>(Action1);</span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">addAction</span>(Action2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>( ui-&gt;contact_table,&amp;QTableView::customContextMenuRequested,<span class="keyword">this</span>,&amp;Mainfunc::Menu_Slot);</span><br><span class="line">    <span class="built_in">connect</span>(Action1, &amp;QAction::triggered,modify_func,&amp;Modify_func::Action1_Slot);</span><br><span class="line">    <span class="built_in">connect</span>(Action2, &amp;QAction::triggered,modify_func,&amp;Modify_func::Action2_Slot);</span><br><span class="line"></span><br><span class="line">    modify_func-&gt;user_id=user_id;<span class="comment">//传递user_id</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(modify_func, &amp;Modify_func::delete_ready,<span class="keyword">this</span>,&amp;Mainfunc::show_cot); <span class="comment">//删除成功后，刷新tableview</span></span><br><span class="line">    <span class="built_in">connect</span>(modify_func, &amp;Modify_func::change_ready,<span class="keyword">this</span>,&amp;Mainfunc::show_cot); <span class="comment">//修改成功后，刷新tableview</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Menu_Slot函数中，首先获取鼠标点击位置的索引，并对点击的位置、选取的项目个数进行检验</p><p>只有在表格中的有效数据位置选中单个项目才会唤出右键菜单</p><p>接着将索引以及Mainfunc页面的model进行传递给了Modify_func对象</p><p>方便后续在数据库中通过这些信息进行查询，以更改&#x2F;删除某一特定联系人的数据。  </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收鼠标右键信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mainfunc::Menu_Slot</span><span class="params">(QPoint p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    QModelIndex index = ui-&gt;contact_table-&gt;<span class="built_in">indexAt</span>(p);<span class="comment">//获取鼠标点击位置项的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index.<span class="built_in">isValid</span>())<span class="comment">//检验数据项是否有效，空白处点击无菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action1-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        Action2-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        QItemSelectionModel* selections =  ui-&gt;contact_table-&gt;<span class="built_in">selectionModel</span>();<span class="comment">//获取当前的选择模型</span></span><br><span class="line">        QModelIndexList selected = selections-&gt;<span class="built_in">selectedIndexes</span>();<span class="comment">//返回当前选择的模型索引</span></span><br><span class="line">        <span class="keyword">if</span>(selected.<span class="built_in">count</span>() ==<span class="number">1</span>) <span class="comment">//选择单个项目时</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//多选，不显示菜单项</span></span><br><span class="line">        &#123;</span><br><span class="line">            Action1-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">            Action2-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先传递数据，再显示菜单</span></span><br><span class="line">        QAbstractItemModel *model =  ui-&gt;contact_table-&gt;<span class="built_in">model</span>(); <span class="comment">// 获取 QTableView 的模型</span></span><br><span class="line">        <span class="comment">//传递当前模型和鼠标位置索引</span></span><br><span class="line">        modify_func-&gt;model=model;</span><br><span class="line">        modify_func-&gt;index=index;</span><br><span class="line"></span><br><span class="line">        sound.wula.<span class="built_in">play</span>();</span><br><span class="line">        tableviewMenu-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());<span class="comment">//显示菜单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生日查询功能"><a href="#生日查询功能" class="headerlink" title="生日查询功能"></a><strong>生日查询功能</strong></h3><p>在实现类似查询倒数xx天过生日的人的时候，网上的解决方案经常会存在一个跨年问题，也有很多人提出了自己的解决方案，我在这里也展示一下我自己想出的解决方案，如有错误欢迎指正。</p><p>如果没有发生跨年，DATE_FORMAT(birth,’%m%d’)先截取DATE类型的数据的月份和日期信息</p><p>接着要求这个数据</p><p>BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,’%m%d’) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,’%m%d’)</p><p>其中：day将会被赋值为用户选择的那个天数，表明在当前日期前后各n天</p><p>假如发生了跨年，则改为：</p><p>BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,’%m%d’) AND STR_TO_DATE(‘12.31’,’%m.%d’)</p><p>OR</p><p>BETWEEN STR_TO_DATE(‘1.1’,’%m.%d’) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,’%m%d’)</p><p>这表明将查询的日期限定在当前日期减去n天后的日期到12.31<strong>或</strong>1.1到当前日期加上n天后的日期</p><p>可以发现，无论是向去年跨一年还是向明年跨一年，这段代码都可以实现查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sound.wula.play();</span><br><span class="line">   QString days <span class="operator">=</span> ui<span class="operator">-</span><span class="operator">&gt;</span>spinBox_3<span class="operator">-</span><span class="operator">&gt;</span>text();</span><br><span class="line">   <span class="type">int</span> daysInt <span class="operator">=</span> days.toInt();</span><br><span class="line">   <span class="operator">/</span><span class="operator">/</span>往前后各数daysInt天</span><br><span class="line">   QSqlQuery query;</span><br><span class="line">   QDate currentDate <span class="operator">=</span> QDate::currentDate();</span><br><span class="line">   QDate past_searchDate <span class="operator">=</span> currentDate.addDays(<span class="operator">-</span>daysInt);</span><br><span class="line">   QDate future_searchDate <span class="operator">=</span> currentDate.addDays(daysInt);</span><br><span class="line">   if(past_searchDate.year()<span class="operator">=</span><span class="operator">=</span>currentDate.year()<span class="operator">&amp;&amp;</span>future_searchDate.year()<span class="operator">=</span><span class="operator">=</span>currentDate.year())&#123;</span><br><span class="line">       query.prepare(&quot;SELECT name, birth, phone, email, type FROM contacts WHERE user_id = :user_id&quot;</span><br><span class="line">                     &quot;AND &quot;</span><br><span class="line">                     &quot;(DATE_FORMAT(birth,&#x27;%m%d&#x27;) BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,&#x27;%m%d&#x27;) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,&#x27;%m%d&#x27;))&quot;);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span>跨年</span><br><span class="line">   &#123;</span><br><span class="line">       query.prepare(&quot;SELECT name, birth, phone, email, type FROM contacts WHERE user_id = :user_id&quot;</span><br><span class="line">                     &quot;AND &quot;</span><br><span class="line">                     &quot;((DATE_FORMAT(birth,&#x27;%m%d&#x27;) BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,&#x27;%m%d&#x27;) AND STR_TO_DATE(&#x27;12.31&#x27;,&#x27;%m.%d&#x27;)))&quot;</span><br><span class="line">                     &quot;OR&quot;</span><br><span class="line">                     &quot;(DATE_FORMAT(birth,&#x27;%m%d&#x27;) BETWEEN STR_TO_DATE(&#x27;1.1&#x27;,&#x27;%m.%d&#x27;) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,&#x27;%m%d&#x27;))&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   query.bindValue(&quot;:user_id&quot;, this<span class="operator">-</span><span class="operator">&gt;</span>user_id);</span><br><span class="line">   query.bindValue(&quot;:days&quot;, daysInt);</span><br><span class="line">   query.exec();</span><br></pre></td></tr></table></figure><h2 id="难点攻破"><a href="#难点攻破" class="headerlink" title="难点攻破"></a><strong>难点攻破</strong></h2><p>&nbsp;</p><h3 id="缺少MySQL驱动的问题"><a href="#缺少MySQL驱动的问题" class="headerlink" title="缺少MySQL驱动的问题"></a><strong>缺少MySQL驱动的问题</strong></h3><p>在QT中使用MySQL的人可能会遭遇一个普遍的问题：QT没有提供MySQL的驱动</p><p>解决方法：先在MySQL的安装路径中找到libmysql.dll和libmysql.lib这两个文件</p><p>接着将这两个文件复制到qt的编译器安装路径（我用的是mingw）的bin文件夹中</p><p>下一步需要利用qt编译qsqlmysql.dll以及qsqlmysqld.dll这两个文件，并将它们添加到qt的编译器安装路径的\plugins\sqldrivers文件夹中，但是这一步较为繁琐，详细流程可以参考：</p><p><a href="https://blog.csdn.net/m0_46273020/article/details/104256219">关于解决Qt MySql没有QMYSQL驱动文件的问题详解_qt可发现的驱动没有qmysql-CSDN博客</a></p><p>我的解决方案是在github上找到了别人编译好的.dll文件，github链接为：</p><p><a href="https://github.com/thecodemonkey86/qt_mysql_driver">thecodemonkey86&#x2F;qt_mysql_driver: Typical symptom: QMYSQL driver not loaded. Solution: get pre-built Qt SQL driver plug-in required to establish a connection to MySQL &#x2F; MariaDB using Qt. Download qsqlmysql.dll binaries built from official Qt source code (github.com)</a></p><p>注意这里新版本的文件可以对版本兼容，但是添加老版本的库文件在新版本无法正常运行</p><p>最好下载对应qt版本的库文件。</p><h3 id="生日查询功能的简洁实现"><a href="#生日查询功能的简洁实现" class="headerlink" title="生日查询功能的简洁实现"></a><strong>生日查询功能的简洁实现</strong></h3><p>在实现年-月-日查询的时候，我希望“0”作为一个默认值，代表所有，这导致一个问题，假如我通过if语句去判断三个QspinBox</p><p>的数值是否为0，根据排列组合，共有8种可能情况，这样写会导致代码的臃肿。</p><p>最终我利用了Qstring可以直接相加的特性，大大简化了代码，代码如下：</p><p>首先获取用户输入，判定每个QspinBox数值是否为0，如果不为0，就加上AND …sql语句</p><p>同样的，在执行查询之前，也判定各个数值是否为0，如果不为0，就对对应的占位符进行赋值</p><p>这样就用较短的代码实现了查询功能。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (year != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        whereClause += <span class="string">&quot; AND YEAR(birth) = :year&quot;</span>;</span><br><span class="line">        yearValue = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (month != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        whereClause += <span class="string">&quot; AND MONTH(birth) = :month&quot;</span>;</span><br><span class="line">        monthValue = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (day != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        whereClause += <span class="string">&quot; AND DAY(birth) = :day&quot;</span>;</span><br><span class="line">        dayValue = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT name, birth, phone, email, type &quot;</span></span><br><span class="line">                  <span class="string">&quot;FROM contacts &quot;</span></span><br><span class="line">                  + whereClause);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:user_id&quot;</span>, <span class="keyword">this</span>-&gt;user_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (year != <span class="string">&quot;0&quot;</span>) query.<span class="built_in">bindValue</span>(<span class="string">&quot;:year&quot;</span>, yearValue);</span><br><span class="line">    <span class="keyword">if</span> (month != <span class="string">&quot;0&quot;</span>) query.<span class="built_in">bindValue</span>(<span class="string">&quot;:month&quot;</span>, monthValue);</span><br><span class="line">    <span class="keyword">if</span> (day != <span class="string">&quot;0&quot;</span>) query.<span class="built_in">bindValue</span>(<span class="string">&quot;:day&quot;</span>, dayValue);</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure><h3 id="exe程序无法运行问题"><a href="#exe程序无法运行问题" class="headerlink" title=".exe程序无法运行问题"></a><strong>.exe程序无法运行问题</strong></h3><p>在将本程序打包为.exe程序供其他人使用的时候，遭遇了一系列问题，但最后都一一解决，接下来我将逐个介绍。</p><h4 id="Cannot-load-lilbrary-Qt6Core-dil问题"><a href="#Cannot-load-lilbrary-Qt6Core-dil问题" class="headerlink" title="Cannot load lilbrary Qt6Core.dil问题"></a>Cannot load lilbrary Qt6Core.dil问题</h4><p>在一开始将.exe发送给其他人时，他们反映会出现Cannot load lilbrary Qt6Core.dil的报错</p><p>这里我已经通过windeployqt 的方式添加了必要的文件，在文件夹中也的确有Qt6Core.dil这一个文件</p><p>查阅资料发现可能是因为缺少libgcc_s_seh-1.dll，libwinpthread.dll，libstdc++-6.dll这三个动态库，于是在编译器（mingw）的bin目录下拷贝这三个动态库，再次打包，发现报错仍然存在。</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105807295.png" alt="image-20240617105807295" style="zoom:50%;"><p>进一步查阅资料，发现需要将编译器的bin目录添加到系统的环境变量中，添加后再次打包，程序在其他电脑上终于可以正常运行。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105827180-1718594953596-72.png" alt="image-20240617105827180"></p><h4 id="无法连接数据库问题"><a href="#无法连接数据库问题" class="headerlink" title="无法连接数据库问题"></a>无法连接数据库问题</h4><p>程序可以运行后，我的舍友尝试使用，点击按钮却没有响应，经排查，是因为没有连接上数据库</p><p>一开始我的数据库建立在本地，即便开放了防火墙，开放数据库的权限（允许任意ip地址的用户登录数据库账号）</p><p>其他人也很难连接到我本地的数据库，借用他的电脑进行测试，发现无法Ping通，而随后我用将ip改为我的阿里云ECS服务器，发现可以Ping通，于是决定将数据库建立在云端。</p><p>一开始我是使用ECS建立数据库，但是在Linux系统中运行MySQL的时候一直出现mysql: error while loading shared libraries: libssl.so.10的问题，于是决定采用RDS数据库服务。</p><p>通过在建立账号-开放权限-用workbench连接建立数据库-设置白名单允许所有ip地址的用户连接</p><p>等一系列操作后，用户终于可以正确连接我的数据库，exe程序也终于可以正常运行。</p><h2 id="结语-源代码获取"><a href="#结语-源代码获取" class="headerlink" title="结语&#x2F;源代码获取"></a>结语&#x2F;源代码获取</h2><p>本项目在11周开始开发，到14周周末基本开发完成，历时接近一个月。</p><p>在这个过程中，我学习了QT的使用，基本的SQL语法，学习了数据库的各种相关操作。</p><p>同时，第一次做一个这么完整的项目，也让我对真正的开发工作有了全新的理解，在开发过程中，各个头文件采取怎样的包含关系，如何做好内存管理，如何减少重复的代码量，如何对相关功能代码进行正确的封装，如何增加代码的可读性，这些都是我在之前的学习过程中从未遇到的挑战，也是我在此项目开发过程中收获的宝贵经验。</p><p>在开发过程中，我也遇到过一个又一个难题，从一开始的QT缺少MySQL驱动，到如何传递user_id保证联系人与账户对应，再到如何实现插入图片的功能，以及如何对图片大小进行压缩（有一次我插入一张画质较高的照片直接导致程序崩溃），到如何实现生日查询、如何发送邮件、如何实现右键菜单、如何进行页面美化以及如何正确打包以便发给其他用户使用，最终这些问题都通过在网上查找各种教程顺利解决，这一过程很好地锻炼了我的解决问题能力以及自学能力，为日后更加深入的学习打好了基础。</p><p>最后，感谢老师细致的教学，感谢所有帮助我测试程序、改进功能的朋友们，也感谢那个辛勤付出的自己。</p><p>本项目源代码已上传github，链接：<a href="https://github.com/HOWILLMAKEIT/UsagiContacts">HOWILLMAKEIT&#x2F;UsagiContacts: C++大作业之乌萨奇通讯录 (github.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HELLO WORLD</title>
      <link href="/2024/06/13/hello-world-1/"/>
      <url>/2024/06/13/hello-world-1/</url>
      
        <content type="html"><![CDATA[<p>我终于部署好了博客网站，欢迎大家多来我的网站。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
