<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode刷题日记</title>
      <link href="/2024/07/26/leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/07/26/leetcode%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>这里还是说一下，大家不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</strong></p><p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p><p>一样的代码多提交几次可能就击败百分之百了…</p><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>my answer</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tear = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( front &lt;= tear)&#123;</span><br><span class="line">            mid = ( tear + front ) /<span class="number">2</span> ; <span class="comment">//向下取整</span></span><br><span class="line">            <span class="keyword">if</span>(target == nums[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( target &lt; nums[mid] )&#123;</span><br><span class="line">                tear = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; nums[mid])&#123;</span><br><span class="line">                front = mid+<span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><p>这题需要使用双指针法——快慢指针</p><p>快指针：寻找新数组的元素（排除不需要的元素val）</p><p>慢指针：指向新数组下标的位置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> fastIndex =<span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[fastIndex] != val)&#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多两次。</p><p>空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</p><p><strong>优化：</strong></p><p>在快慢指针的使用中，最多需要遍历序列两次，其中有很多都只是简单的将后面的元素赋值到前面，这个开销还是比较大的</p><p>可以用另一种双指针，一个在后面，一个在前面，如果nums[left]的数值为val，就用nums[right]覆盖它，随后right向左移动，如果覆盖后nums[left]仍为val,就在此重复上述操作，直到nums[left]!&#x3D;val,则将left向右移动</p><p>这个过程只需要遍历序列中的元素一次</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left= <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[left] == val)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 为序列的长度。我们只需要遍历该序列至多一次。</p><p>空间复杂度：<em>O</em>(1)。我们只需要常数的空间保存若干变量。</p><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>非递减排序（Non-decreasing sort）是一种排序算法，它确保排序后的序列中的每个元素都<strong>不小于</strong>其前一个元素。换句话说，序列中的元素按非递减顺序排列，即从小到大排列。这种排序方式也被称为升序排序。</p><p>基本思路：先平方再排序，平方的时间复杂度为：O(n)，排序的时间复杂度为O(n^2)，如果用sort函数排序，时间复杂度为O(log n )</p><p>注意到数组本身就有序，是因为负数的存在导致平方后顺序可能改变，也就是说最左侧的负数的平方可能是最大值，这个时候就可以利用双指针法，一个指向最左侧，另一个指向最右侧，判断两个数据的平方的大小</p><p>这个算法的时间复杂度是O(n)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="comment">//static int i = 1;这里不能用静态变量，因为这个函数不是一次性的</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right]*nums[right])&#123;</span><br><span class="line">            result[nums.<span class="built_in">size</span>()-i] = nums[left]*nums[left];</span><br><span class="line">            left++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result[nums.<span class="built_in">size</span>()-i] = nums[right]*nums[right];</span><br><span class="line">            right--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h3><p>这里需要用到<strong>滑动窗口</strong></p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些，这里的思想是移动窗口右侧保证窗口内数据和大于target，移动窗口左侧保证窗口最短</p><p>写了两个while，每个元素最多访问两次，也就是2*n，时间复杂度O(n)，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                length = right - left +<span class="number">1</span> ; </span><br><span class="line">                result = result&lt;length ? result : length ; </span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="58区间和"><a href="#58区间和" class="headerlink" title="58区间和"></a>58区间和</h3><p>KamaCoder（第九期模拟笔试）</p><p>如果采用常规思路从arr[a]加到arr[b]这道题会超时</p><p>这里涉及一个新的算法：<strong>前缀和</strong></p><p>前缀和就是在一个新的列表中存储，前n个数字的和</p><p>如果我们需要区间2-5的和，只需要用前缀和相减: p[5]-p[1]</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">frontSum</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;n;i++)&#123;</span><br><span class="line">        std::cin&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">if</span>( i == <span class="number">0</span>) frontSum[i] = arr[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        frontSum[i] = frontSum[i<span class="number">-1</span>]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) std:: cout&lt;&lt;frontSum[b] &lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">else</span> std:: cout&lt;&lt; frontSum[b]-frontSum[a<span class="number">-1</span>]&lt;&lt;std:: endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便这样还是会输出超限，因为用了cin和cout</p><p>在需要多次输入和输出的时候，使用scanf &amp; printf 会更快</p><p>修改了代码后发现还是超时，但是将while的循环条件中的scanf改成~scanf就能通过，原因是：</p><p>~表示反码,EOF(end of file ) 的值是-1，-1的反码是0，当遇到错误或者输入为ctrl+Z &#x2F; ctrl+D时，scanf函数的返回值为EOF，取反后得到0，使循环退出</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> presum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">preSum</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">        presum += temp;</span><br><span class="line">        preSum[i] = presum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a,b,sum;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b))&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) sum =  preSum[b];</span><br><span class="line">        <span class="keyword">else</span> sum= preSum[b]-preSum[a<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="59螺旋矩阵"><a href="#59螺旋矩阵" class="headerlink" title="59螺旋矩阵"></a>59螺旋矩阵</h3>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学习深度学习</title>
      <link href="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据操作-数据预处理"><a href="#数据操作-数据预处理" class="headerlink" title="数据操作 + 数据预处理"></a>数据操作 + 数据预处理</h2><p>N维数组是机器学习和神经网络学习的<strong>主要数据结构</strong></p><p>创建数组的需要：形状、数据类型、每个元素的值</p><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><h4 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h4><p>行和列都是从0开始，-1可以表示最后一行or最后一列</p><p>访问元素: 例如[1:3,1:]表示访问第1、2行以及从第一列开始的所有列</p><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240726170521499.png" alt="image-20240726170521499"></p><p>[::3,::2] ::3表示切片，每三行取一行</p><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240726170626631.png" alt="image-20240726170626631"></p><p>[3]表示第三行[,3]表示第三列</p><h4 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.arange(<span class="number">12</span>)</span><br><span class="line"><span class="comment">#随机</span></span><br><span class="line">torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">#全0</span></span><br><span class="line">torch.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240726172228760.png" alt="image-20240726172228760"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#赋值</span></span><br><span class="line">torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Z的shape和数据类型都与y相同</span></span><br><span class="line">Z = torch.zeros_like(Y)</span><br></pre></td></tr></table></figure><h4 id="访问张量"><a href="#访问张量" class="headerlink" title="访问张量"></a>访问张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.shape <span class="comment">#torch.size([12])</span></span><br><span class="line">x.numel() <span class="comment">#12</span></span><br></pre></td></tr></table></figure><h4 id="修改张量"><a href="#修改张量" class="headerlink" title="修改张量"></a>修改张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X= x.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">X.shape <span class="comment">#torch.Size([3, 4])</span></span><br></pre></td></tr></table></figure><h4 id="张量运算"><a href="#张量运算" class="headerlink" title="张量运算"></a>张量运算</h4><p>加减乘除求幂</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">x + y, x - y, x * y, x / y, x ** y  <span class="comment"># **运算符是求幂运算</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>]),</span><br><span class="line"> tensor([-<span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">6.</span>]),</span><br><span class="line"> tensor([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>, <span class="number">16.</span>]),</span><br><span class="line"> tensor([<span class="number">0.5000</span>, <span class="number">1.0000</span>, <span class="number">2.0000</span>, <span class="number">4.0000</span>]),</span><br><span class="line"> tensor([ <span class="number">1.</span>,  <span class="number">4.</span>, <span class="number">16.</span>, <span class="number">64.</span>]))</span><br></pre></td></tr></table></figure><p>更多计算</p><p>指数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.exp(x)</span><br></pre></td></tr></table></figure><p>求和</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X.<span class="built_in">sum</span>()<span class="comment">#结果是一个元素</span></span><br></pre></td></tr></table></figure><h4 id="连结张量"><a href="#连结张量" class="headerlink" title="连结张量"></a>连结张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">torch.cat((X, Y), dim=<span class="number">0</span>), <span class="comment">#在行上合并</span></span><br><span class="line">torch.cat((X, Y), dim=<span class="number">1</span>)  <span class="comment">#在列上合并</span></span><br></pre></td></tr></table></figure><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p><strong>即使形状不同，我们仍然可以通过调用 *广播机制*（broadcasting mechanism）来执行按元素操作</strong>]。 这种机制的工作方式如下：</p><ol><li>通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；</li><li>对生成的数组执行按元素操作。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">a, b</span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a + b</span><br><span class="line"><span class="comment">########################</span></span><br><span class="line">tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure><h4 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tensor-&gt;numpy</span></span><br><span class="line">A = X.numpy()</span><br><span class="line"><span class="comment">#numpy-&gt;tensor</span></span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="comment">#当tensor大小为1时，tensor-&gt;python标量 </span></span><br><span class="line">a= torch.tensor([<span class="number">3.5</span>])</span><br></pre></td></tr></table></figure><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>本节将简要介绍使用<code>pandas</code>预处理原始数据，并将原始数据转换为张量格式的步骤。 后面的章节将介绍更多的数据预处理技术。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># &#x27;..&#x27;代表本目录的父目录</span></span><br><span class="line"><span class="comment"># exist_ok=True表示假如已经存在data目录，不会重新创建且不会报错</span></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># data_file存储data目录下文件house_tiny.csv的路径</span></span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 用write的方式打开</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里缺失了数据，这里我们考虑插值法处理</p><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727114348965.png" alt="image-20240727114348965"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="comment"># inputs获取第0、1列 outputs获取第2列</span></span><br><span class="line"><span class="comment"># .iloc是pandas库中基于位置进行索引的函数</span></span><br><span class="line">inputs, outputs = data.iloc[:, <span class="number">0</span>:<span class="number">2</span>], data.iloc[:, -<span class="number">1</span>]</span><br><span class="line"><span class="comment"># .mean用于获取均值，numeric_only=True表示只考虑数值</span></span><br><span class="line">inputs = inputs.fillna(inputs.mean(numeric_only=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727114906568.png" alt="image-20240727114906568"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟变量  dummy_na=True表示要将缺失值（NaN）转换为一个新的虚拟变量</span></span><br><span class="line">inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727115335144.png" alt="image-20240727115335144"></p><p>转化为张量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">X = torch.tensor(inputs.to_numpy(dtype=<span class="built_in">float</span>))</span><br><span class="line">y = torch.tensor(outputs.to_numpy(dtype=<span class="built_in">float</span>))</span><br><span class="line">X, y</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727115521841.png" alt="image-20240727115521841"></p><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="线性代数实现"><a href="#线性代数实现" class="headerlink" title="线性代数实现"></a>线性代数实现</h3><p><strong>标量</strong>：用只有一个元素的张量表示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor(<span class="number">3.0</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p><strong>向量</strong>：<strong>标量值组成的列表</strong></p><p>认为列向量是向量的默认方向</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>用索引访问到的当个元素也是张量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>]</span><br><span class="line"><span class="comment"># tensor(3)</span></span><br></pre></td></tr></table></figure><p>向量的长度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p><strong>矩阵</strong>：用m*n的张量表示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>转制</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure><p>对于对称矩阵，满足：</p><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727153227299.png" alt="image-20240727153227299"></p><p><strong>张量</strong>：[<strong>就像向量是标量的推广，矩阵是向量的推广一样，我们可以构建具有更多轴的数据结构</strong>]。 张量（本小节中的“张量”指代数对象）是描述具有任意数量轴的n维数组的通用方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727153540597.png" alt="image-20240727153540597"></p><h3 id="张量算法"><a href="#张量算法" class="headerlink" title="张量算法"></a>张量算法</h3><p>两个矩阵按元素相乘*<strong>Hadamard积*</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A * B</span><br></pre></td></tr></table></figure><h4 id="降维求和"><a href="#降维求和" class="headerlink" title="降维求和"></a>降维求和</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>默认情况下，调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量。 我们还可以[<strong>指定张量沿哪一个轴来通过求和降低维度</strong>]。 以矩阵为例，为了通过求和所有行的元素来降维（轴0），可以在调用函数时指定<code>axis=0</code>。 由于输入矩阵沿0轴降维以生成输出向量，<strong>因此输入轴0的维数在输出形状中消失</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 沿着第0轴进行求和</span></span><br><span class="line"><span class="comment"># A是一个5*4的矩阵</span></span><br><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis0, A_sum_axis0.shape</span><br><span class="line"></span><br><span class="line">(tensor([<span class="number">40.</span>, <span class="number">45.</span>, <span class="number">50.</span>, <span class="number">55.</span>]), torch.Size([<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727155109468.png" alt="image-20240727155109468"></p><p>也可以沿着两个维度求和</p><p>例如下列代码对X沿着0轴和1轴求和</p><p>可以理解为先让两个3*4矩阵相加，得到一个3 * 4矩阵</p><p>然后将每一个长度为4的向量相加，得到tensor([60, 66, 72, 78])</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">X_sum_axis01 = X.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">X_sum_axis01</span><br><span class="line"></span><br><span class="line">(tensor([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">          [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">          [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"> </span><br><span class="line">         [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">          [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">          [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]]),</span><br><span class="line">tensor([<span class="number">60</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">78</span>])</span><br></pre></td></tr></table></figure><h4 id="非降维求和"><a href="#非降维求和" class="headerlink" title="非降维求和"></a>非降维求和</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">A_sum_axis1,sum_A</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 降维求和结果</span></span><br><span class="line">(tensor([ <span class="number">6.</span>, <span class="number">22.</span>, <span class="number">38.</span>, <span class="number">54.</span>, <span class="number">70.</span>]),</span><br><span class="line"> <span class="comment"># 非降维求和结果，5*1，还是两个维度</span></span><br><span class="line"> tensor([[ <span class="number">6.</span>],</span><br><span class="line">         [<span class="number">22.</span>],</span><br><span class="line">         [<span class="number">38.</span>],</span><br><span class="line">         [<span class="number">54.</span>],</span><br><span class="line">         [<span class="number">70.</span>]]))</span><br></pre></td></tr></table></figure><p>如果我们想沿[<strong>某个轴计算<code>A</code>元素的累积总和</strong>]， 比如<code>axis=0</code>（按行计算），可以调用<code>cumsum</code>函数。 此函数不会沿任何轴降低输入张量的维度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A,A.cumsum(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">(tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         [<span class="number">12.</span>, <span class="number">13.</span>, <span class="number">14.</span>, <span class="number">15.</span>],</span><br><span class="line">         [<span class="number">16.</span>, <span class="number">17.</span>, <span class="number">18.</span>, <span class="number">19.</span>]]),</span><br><span class="line"> tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">         [ <span class="number">4.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>, <span class="number">10.</span>],</span><br><span class="line">         [<span class="number">12.</span>, <span class="number">15.</span>, <span class="number">18.</span>, <span class="number">21.</span>],</span><br><span class="line">         [<span class="number">24.</span>, <span class="number">28.</span>, <span class="number">32.</span>, <span class="number">36.</span>],</span><br><span class="line">         [<span class="number">40.</span>, <span class="number">45.</span>, <span class="number">50.</span>, <span class="number">55.</span>]]))</span><br></pre></td></tr></table></figure><h4 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.mean() , A.<span class="built_in">sum</span>() / A.numel()</span><br></pre></td></tr></table></figure><p>同样，计算平均值的函数也可以沿指定轴降低张量的维度</p><p>例如，求A沿着0轴方向的平均值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.mean(axis=<span class="number">0</span>), A.<span class="built_in">sum</span>(axis=<span class="number">0</span>) / A.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.dot(x, y)</span><br></pre></td></tr></table></figure><p><strong>我们可以通过执行按元素乘法，然后进行求和来表示两个向量的点积</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.<span class="built_in">sum</span>(x * y)</span><br></pre></td></tr></table></figure><h4 id="矩阵-向量积"><a href="#矩阵-向量积" class="headerlink" title="矩阵-向量积"></a>矩阵-向量积</h4><p>例如A是一个m*n的矩阵，x是一个长度为n的向量</p><p>则A与x的积为一个长度为m的列向量，其中第i个元素为矩阵中第i行向量与x的点积</p><p><img src="/2024/07/25/%E5%8A%A8%E6%89%8B%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/image-20240727162328237.png" alt="image-20240727162328237"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.shape, x.shape, torch.mv(A, x)</span><br><span class="line"></span><br><span class="line">(torch.Size([<span class="number">5</span>, <span class="number">4</span>]), torch.Size([<span class="number">4</span>]), tensor([ <span class="number">14.</span>,  <span class="number">38.</span>,  <span class="number">62.</span>,  <span class="number">86.</span>, <span class="number">110.</span>]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习记录</title>
      <link href="/2024/07/25/python/"/>
      <url>/2024/07/25/python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python学习记录"><a href="#Python学习记录" class="headerlink" title="Python学习记录"></a>Python学习记录</h1><h2 id="标准库OS"><a href="#标准库OS" class="headerlink" title="标准库OS"></a>标准库OS</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>系统相关变量和操作</p><p>文件和目录相关操作</p><p>执行命令和管理进程</p><h3 id="1、系统相关"><a href="#1、系统相关" class="headerlink" title="1、系统相关"></a>1、系统相关</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 系统相关</span></span><br><span class="line"><span class="built_in">print</span>(os.name) <span class="comment"># nt window操作系统 操作系统类别</span></span><br><span class="line"><span class="built_in">print</span>(os.environ)   <span class="comment"># 系统的环境变量</span></span><br><span class="line"><span class="comment"># 利用不同系统的分隔符差异</span></span><br><span class="line"><span class="built_in">print</span>(os.sep)    <span class="comment"># 路径分隔符 Windows是\，Linux是/</span></span><br><span class="line"><span class="built_in">print</span>(os.pathsep)   <span class="comment"># 路径组件分隔符  Windows是;，Linux是:</span></span><br><span class="line"><span class="built_in">print</span>(os.linesep)   <span class="comment"># 换行符 Windows是\n，Linux是\n</span></span><br></pre></td></tr></table></figure><h4 id="2、文件和目录操作"><a href="#2、文件和目录操作" class="headerlink" title="2、文件和目录操作"></a>2、文件和目录操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件和目录</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;os.test&#x27;</span>)     <span class="comment"># 在当前路径创建一个目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;os.test&#x27;</span>)     <span class="comment"># 在当前路径删除空目录</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;os.test/test&#x27;</span>) <span class="comment"># 在当前路径创建多级目录</span></span><br><span class="line">os.remove(<span class="string">&#x27;os.test/test&#x27;</span>)   <span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">print</span>(os.stat(<span class="string">&#x27;os.test&#x27;</span>))       <span class="comment"># 目录状态</span></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())          <span class="comment"># 返回工作目录的路径</span></span><br></pre></td></tr></table></figure><p><img src="/2024/07/25/python/image-20240726214345854.png" alt="image-20240726214345854"></p><p>os的子包：os.path</p><p>分离路径和文件名</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = os.getcwd() + <span class="string">r&quot;\1-1.py&quot;</span></span><br><span class="line"><span class="built_in">print</span>(os.path.split(file))</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># (&#x27;C:\\Users\\86181\\Desktop\\project\\python&#x27;, &#x27;1-1.py&#x27;)</span></span><br></pre></td></tr></table></figure><p>判断是否为绝对路径</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.path.isabs(file)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>判断目录是否存在</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.path.exists(file))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>查找文件&#x2F;目录时间</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最近访问时间</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getatime(os.getcwd()))  <span class="comment"># 1722002047.3365378时间戳</span></span><br><span class="line"><span class="comment"># 创建时间</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getctime(os.getcwd()))  <span class="comment"># 1721872440.6129136</span></span><br></pre></td></tr></table></figure><p>文件大小</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.path.getsize(file))  <span class="comment"># 单位字节</span></span><br></pre></td></tr></table></figure><h4 id="3、执行命令"><a href="#3、执行命令" class="headerlink" title="3、执行命令"></a>3、执行命令</h4><p>管理进程在Linux系统上才好用，在windows上用处不大，这里不做介绍</p><p>命令：可执行程序都可以叫命令</p><p>但是这种方法在新版本的python中已经不推荐了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;helloworld.py&#x27;</span>)</span><br><span class="line">os.system(<span class="string">&#x27;ipconfig&#x27;</span>)  <span class="comment"># 执行windows命令</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（更新完毕）</title>
      <link href="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>教程来源 ：油管搜索：my code school</p><h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><p>数据结构定义：</p><p>a data structure is a way to store and organize data in a computer, </p><p>so that it can be used efficiently.</p><p>我们常说的“数据结构”其实分为两种概念：</p><p>1)ADT:  abstract data types –定义我们想要实现的功能，不讨论实现细节</p><p>2)Implementation（实现）–设计程序实现功能</p><h2 id="链表linked-list"><a href="#链表linked-list" class="headerlink" title="链表linked list"></a>链表linked list</h2><h3 id="为什么需要链表？"><a href="#为什么需要链表？" class="headerlink" title="为什么需要链表？"></a>为什么需要链表？</h3><p>在使用数组申请内存空间的时候，数组的大小往往是限定好的，例如: int A[4];这样就申请了4*4&#x3D;16个字节的空间</p><p>当你想要插入第五个元素的时候，由于这块空间附近的空间可能已经被内存管理器分配给了其他变量，这导致数组不具有扩展性。</p><p>想要扩展，只能重新创建一个数组，然后把原来的数据复制进去，由于需要遍历所有元素，因此时间复杂度为O(n)，空间复杂度也为O(n)</p><p>因此，我们需要一个<strong>更具有扩展性的数据结构</strong>——<strong>链表</strong></p><h3 id="链表的扩展性"><a href="#链表的扩展性" class="headerlink" title="链表的扩展性"></a>链表的扩展性</h3><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240709104317964.png" alt="image-20240709104317964"></p><p> 数组的特点是申请一整块连续的内存块</p><p>而链表可扩展性的秘诀在于为每一个数据申请单独的内存块（分散）</p><p>对于数组，我们可以通过内存块的首地址+数组的位置计算出某一元素所在的位置，例如数组A的首地址为200，那么A[4]就是200+4*4&#x3D;216</p><p>但是对于链表，由于内存块是分散的，如何找到对应的地址就是一个新的问题</p><p>解决方案是，在一个块中，既存放数据，又存放下一个元素（内存块）的地址</p><p>也就是说一个内存块存放两个变量，一个是<u>特定类型的元素</u>，另一个是<u>下一个元素的数据类型对应的指针</u></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240709104501024.png" alt="image-20240709104501024"></p><h3 id="节点-node"><a href="#节点-node" class="headerlink" title="节点-node"></a>节点-node</h3><p>把每一个内存块（包括元素和指针）看成一个整体，这样的整体称为：node 节点</p><p>在C&#x2F;C++中，用结构体<strong>struct</strong>定义这样一个节点</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 存储数据  4字节</span></span><br><span class="line">    Node* next; <span class="comment">// 指向下一个节点的指针  4字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这里的指针类型为 Node* ，表明这里存放的是下一个节点的地址</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240709110040745.png" alt="image-20240709110040745"></p><h3 id="时间-空间复杂度"><a href="#时间-空间复杂度" class="headerlink" title="时间&#x2F;空间复杂度"></a>时间&#x2F;空间复杂度</h3><p>1、在链表中，插入一个数据需要创建节点-找到插入的位置-连接</p><p>因此对应的时间复杂度为O(n），空间复杂度为O(1)</p><p>2、删除数据需要找到删除的位置-删除节点-<a href>重新连接</a></p><p>因此对应的时间复杂度为O(n），空间复杂度为O(1)</p><h3 id="C-实现-单向链表"><a href="#C-实现-单向链表" class="headerlink" title="C++实现-单向链表"></a>C++实现-单向链表</h3><p>单向链表：single linked list </p><h4 id="定义节点"><a href="#定义节点" class="headerlink" title="定义节点"></a>定义节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> * head;<span class="comment">//全局变量或者写在main函数里面都可以</span></span><br></pre></td></tr></table></figure><p>接口：</p><h4 id="1、从头-尾插入"><a href="#1、从头-尾插入" class="headerlink" title="1、从头&#x2F;尾插入"></a>1、从头&#x2F;尾插入</h4><p>注意节点必须创建在堆区，如果创建在栈区，会在函数调用借结束后释放内存。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span> <span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Node *temp = <span class="keyword">new</span> <span class="built_in">Node</span>();<span class="comment">//创建节点</span></span><br><span class="line">    temp-&gt;data = x;</span><br><span class="line">    temp-&gt;next = head;<span class="comment">//连接</span></span><br><span class="line">    head = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert_end</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;</span><br><span class="line">    Node * new_node = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    new_node-&gt;data= x;</span><br><span class="line">    new_node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Node* temp = head;</span><br><span class="line">    <span class="comment">//定位    </span></span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next=new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在任意位置插入"><a href="#2、在任意位置插入" class="headerlink" title="2、在任意位置插入"></a>2、在任意位置插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    Node* new_node =<span class="keyword">new</span> <span class="built_in">Node</span>(); </span><br><span class="line">    new_node-&gt;data = x;</span><br><span class="line">    new_node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//在这里1代表初始位置</span></span><br><span class="line">    <span class="keyword">if</span>( index == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        new_node-&gt;next = head;</span><br><span class="line">        head = new_node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位    </span></span><br><span class="line">    Node *temp= head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( temp != <span class="literal">NULL</span>)</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置无效！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node-&gt;next=temp-&gt;next;</span><br><span class="line">    temp-&gt;next=new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、输出链表"><a href="#3、输出链表" class="headerlink" title="3、输出链表"></a>3、输出链表</h4><p>a.迭代方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的head是局部变量的head，不是全局变量，所以不会影响全局变量head</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">( Node * head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;head-&gt;data&lt;&lt;  <span class="string">&quot; -&gt; &quot;</span>   &lt;&lt;endl;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.递归方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归方式输出链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( Node * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">// 退出条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;-&gt; &quot;</span>;</span><br><span class="line">    <span class="built_in">Print</span>(p-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反向输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( Node * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">// 退出条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Print</span>(p-&gt;next);</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;&lt;- &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在任意位置删除节点"><a href="#4、在任意位置删除节点" class="headerlink" title="4、在任意位置删除节点"></a>4、在任意位置删除节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">( <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="comment">//如果要删去开头节点</span></span><br><span class="line">    <span class="keyword">if</span> ( index == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定位到前一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; index<span class="number">-2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置无效！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * temp1 = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp1-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、链表反转"><a href="#5、链表反转" class="headerlink" title="5、链表反转"></a>5、链表反转</h4><p>a.迭代方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node ** 是因为要传入的是 &amp;head</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(Node ** head)</span></span>&#123;</span><br><span class="line">    Node* prev = <span class="literal">NULL</span>;</span><br><span class="line">    Node* current = *head;</span><br><span class="line">    Node* next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = current-&gt;next; <span class="comment">// 保存下一个节点</span></span><br><span class="line">        current-&gt;next = prev; <span class="comment">// 反转当前节点的指针</span></span><br><span class="line">        prev = current;       <span class="comment">// 移动 prev 到当前节点</span></span><br><span class="line">        current = next;       <span class="comment">// 移动 current 到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *head = prev; <span class="comment">// 更新头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.递归方式实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的head是全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">REverse</span><span class="params">(Node  * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">REverse</span>( p-&gt;next );</span><br><span class="line">    p-&gt;next-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如head是局部变量</span></span><br><span class="line"><span class="comment">//REverse函数需要返回第一个节点的地址</span></span><br><span class="line"><span class="function">Node* <span class="title">REverse</span> <span class="params">( Node * p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * head = <span class="built_in">REverse</span>( p-&gt;next );</span><br><span class="line">    p-&gt;next-&gt;next = p;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span> ;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现-双向链表"><a href="#C-实现-双向链表" class="headerlink" title="C++实现-双向链表"></a>C++实现-双向链表</h3><p>doubly linked list</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240712172237302.png" alt="image-20240712172237302"></p><h4 id="定义节点-1"><a href="#定义节点-1" class="headerlink" title="定义节点"></a>定义节点</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">    Node * prev;<span class="comment">// previous</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、从头-尾插入-1"><a href="#1、从头-尾插入-1" class="headerlink" title="1、从头&#x2F;尾插入"></a>1、从头&#x2F;尾插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertAtHead</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node * temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        head=temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    temp-&gt;next=head;</span><br><span class="line">    head-&gt;prev=temp;</span><br><span class="line">    head=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertAtTail</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Node * NewNode = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    NewNode-&gt;data=x;</span><br><span class="line">    NewNode-&gt;prev=<span class="literal">NULL</span>;</span><br><span class="line">    NewNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    NewNode-&gt;prev=temp;</span><br><span class="line">    temp-&gt;next=NewNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在任意位置插入-1"><a href="#2、在任意位置插入-1" class="headerlink" title="2、在任意位置插入"></a>2、在任意位置插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReversePrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;&lt;-&gt;&quot;</span>;</span><br><span class="line">        temp=temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    Node * NewNode = <span class="keyword">new</span> <span class="built_in">Node</span>( );</span><br><span class="line">    NewNode-&gt;data = x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">1</span>)&#123;<span class="comment">//从头插入</span></span><br><span class="line">        NewNode-&gt;next=head;</span><br><span class="line">        head-&gt;prev=NewNode;</span><br><span class="line">        head=NewNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * temp= head;</span><br><span class="line">    <span class="comment">//定位到目标位置前一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;输入的位置无效&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * NextNode = temp-&gt;next;</span><br><span class="line"></span><br><span class="line">    NewNode-&gt;next=NextNode;</span><br><span class="line">    <span class="keyword">if</span>(NextNode != <span class="literal">NULL</span>)</span><br><span class="line">    NextNode-&gt;prev=NewNode;</span><br><span class="line">    temp-&gt;next=NewNode;</span><br><span class="line">    NewNode-&gt;prev=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、输出链表-1"><a href="#3、输出链表-1" class="headerlink" title="3、输出链表"></a>3、输出链表</h4><p>迭代方式和递归方式的实现和单链表相同，不再赘述</p><p>反向输出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReversePrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;&lt;-&gt;&quot;</span>;</span><br><span class="line">        temp=temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717121055963.png" alt="image-20240717121055963"></p><p>只能访问栈顶,**last-in-first-out(LIFO)**最后加入的元素最先出去</p><p>定义：a list with the restriction that insertion and deletion can be performed only from one end , called the top.</p><p>operations:</p><p>Push(添加元素)、Pop(移出元素)、Top（返回栈顶的元素）、IsEmpty()这些操作的时间复杂度都是O(1) </p><p><u>在很多软件中，ctrl+z撤回的操作就是用栈来实现的</u></p><h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 101</span></span><br><span class="line"><span class="type">int</span> A[MAX_SIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( top == MAX_SIZE<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: stack overflow&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// top++;</span></span><br><span class="line">    <span class="comment">// A[top]=x;</span></span><br><span class="line">    A[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: No element to pop&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;ERROR: No element&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>如果采用<u>动态数组</u>（当数组满了以后创建一个大小为原来的两倍的数组）</p><p>一次push的最好时间复杂度为O(1),最差为O(n)</p><p>n次push的时间复杂度为O(n),平均每次为O(1)</p><h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><p>相比数组实现，链表实现不需要考虑oveflow(溢出)的问题</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node * next;</span><br><span class="line">&#125;;</span><br><span class="line">Node* top = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Node * temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    temp-&gt;data=x;</span><br><span class="line">    temp-&gt;next=top;</span><br><span class="line">    top = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Stack is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node * temp;</span><br><span class="line">    temp = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TopElement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Stack is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h4><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717143514898.png" alt="image-20240717143514898"></p><p>在C++的标准库STL（standard template library)中已经有一个stack库</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span><span class="comment">//stack 库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数的时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//函数的空间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">char</span> C[],<span class="type">int</span> n )</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; S;<span class="comment">//创建一个char类型的栈S</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(C[i]);</span><br><span class="line">    &#125;<span class="comment">//时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;<span class="comment">//时间复杂度O(n)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> C[<span class="number">51</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter a string:  &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(C,<span class="number">51</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">strlen</span>(C);</span><br><span class="line">    <span class="built_in">Reverse</span>(C,<span class="built_in">strlen</span>(C));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在反转字符的时候，这并不是最好的算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">char</span> C[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="type">char</span> temp = C[i];</span><br><span class="line">        C[i]= C[j];</span><br><span class="line">        C[j]= temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> C[<span class="number">51</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter a string:  &quot;</span>;</span><br><span class="line">    cin.<span class="built_in">getline</span>(C,<span class="number">51</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">strlen</span>(C);</span><br><span class="line">    <span class="built_in">Reverse</span>(C,<span class="built_in">strlen</span>(C));</span><br><span class="line">    cout&lt;&lt;C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法的时间复杂度为O(n)空间复杂度为O(1);</p><h4 id="2、反转链表"><a href="#2、反转链表" class="headerlink" title="2、反转链表"></a>2、反转链表</h4><p>实际上，使用递归的方法反转一个链表就使用了隐式的栈(implicit stack)</p><p>下面是使用显式的栈反转链表的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( head == <span class="literal">NULL</span> )<span class="keyword">return</span>;</span><br><span class="line">    stack&lt;Node*&gt; S;<span class="comment">//构建栈</span></span><br><span class="line">    Node * temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        S.<span class="built_in">push</span>(temp);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = S.<span class="built_in">top</span>();</span><br><span class="line">    head = temp;</span><br><span class="line">    S.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp-&gt;next = S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、检查括号匹配性"><a href="#3、检查括号匹配性" class="headerlink" title="3、检查括号匹配性"></a>3、检查括号匹配性</h4><p>记得有一次上机测试我用计算规定当出现（时候+1，当出现）时候-1，同时限制数字之和不为负数【防止出现“)(”的情况】这种方法解出了题目</p><p>但是我的这种方法无法判定（【）】这种式子是否正确</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717211428517.png" alt="image-20240717211428517"></p><p>那么，如何解决这个问题呢？</p><p>把左括号逐个丢入栈中，每次遇到右括号，都先判断一下其与相邻的括号是否配对，如果配对，就将相邻的括号pop掉（有点像消消乐），如果不配对，说明括号不配对</p><p>这里运用到了<strong>last in firtst out</strong> 的思想，具体表现为<strong>最后进入的最早闭合</strong></p><p>有的编译器&#x2F;编辑器（如vscode）可以检测出代码括号不配对这种错误，其实就是用栈实现的</p><p>具体实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBalanceParenthesis</span><span class="params">(<span class="type">char</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(A);</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == <span class="string">&#x27;[&#x27;</span>||A[i] == <span class="string">&#x27;(&#x27;</span> || A[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(A[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || s.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || s.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>() || s.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main函数（测试用）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> A[<span class="number">10</span>];</span><br><span class="line">        cin.<span class="built_in">getline</span>(A,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">CheckBalanceParenthesis</span>(A))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;括号配对&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;括号不配对&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀、中缀、后缀"><a href="#前缀、中缀、后缀" class="headerlink" title="前缀、中缀、后缀"></a>前缀、中缀、后缀</h3><p>prefix infix postfix</p><p>操作数：operand</p><p>操作符：operator</p><p>对于一个表达式，我们可以有中缀表达式、前缀表达式、后缀表达式</p><p>它们的含义是相同的，我们日常中使用比较频繁的是中缀表达式</p><p>但是，中缀表达式存在歧义问题，例如3+5*2的计算，是通过规定 * 的优先级在+之上才有了唯一的结果，除此之外，中缀表达式还通过规定括号的优先级，多个连续的幂运算的优先级来避免歧义</p><p>而逻辑学家和数学家则找到了<strong>能够有效避免歧义的表示方法</strong>，即前缀表达式(波兰表达式)和后缀表达式(逆波兰表达式 )，这两种表达式<strong>不需要规定运算符的优先级和结合性，更不用使用括号</strong></p><p>从编程的角度而言，后缀表达式是<u>最容易解析、求值的时间和内存代价最小</u>的</p><p>中缀表达式不需要空格，但后缀和前缀表达式需要空格区分，例如2333*意义不明，22 33 * 和 223 3 *则明确</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240717220508557.png" alt="image-20240717220508557"></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240718095209122.png" alt="image-20240718095209122"></p><h4 id="后缀表达式的计算："><a href="#后缀表达式的计算：" class="headerlink" title="后缀表达式的计算："></a>后缀表达式的计算：</h4><p>注意到这些运算符都是二元运算符，每个运算符要找到它的两个操作数（<strong>从左往右</strong>）</p><p>例如：2 3 * 5 4 * + 9 - ， 第一个* 的操作数是2 3 ，第二个为 5 和 4，即化为 6 20 + 9 -，+的操作数为6 20 即：26 9 - ，-的操作数为 26 9，即17</p><p><strong>这个计算过程可以用栈很好地进行</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">EvaluatePostfix</span><span class="params">(<span class="type">char</span> A[])</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    string numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; A[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(A[i])) &#123;</span><br><span class="line">            numStr += A[i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!numStr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">//例如当出现 23 5...的时候，push的是23而不是2和3</span></span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(numStr));</span><br><span class="line">                    numStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> op2=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> op1=s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span>(A[i])&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1+op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1-op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1*op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        s.<span class="built_in">push</span>(op1/op2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span> (!numStr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(numStr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前缀表达式的计算同理</p><p>用代码计算前缀表达式的时候，其实只需要改动一步：从后往前遍历，这样就可以像计算后缀表达式一样利用栈来计算了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从后向前遍历字符数组 A</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">strlen</span>(A) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; A[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            numStr += A[i];</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><h4 id="表达式的转换"><a href="#表达式的转换" class="headerlink" title="表达式的转换"></a>表达式的转换</h4><p>中缀-&gt;后缀</p><p>注意到中缀转后缀的过程中，操作符的次序可能变化，但是操作数的次序不变</p><p>因此读取到操作数时，可以直接将其放入表达式中</p><p>那么如何确定运算符的次序呢？</p><p>有一种算法是：</p><p>当新的操作符的优先级比栈顶操作符的优先级高时，压入栈</p><p>反之，栈顶元素弹出，直到将新元素压入栈为止</p><p>括号处理：（直接压入栈中，出现），就使栈顶元素弹出，直到”（“弹出，注意弹出的（不需要加入表达式中。</p><p>在这个过程中，如果遇到操作数，直接加入表达式即可，同时最后如果栈中还有操作符，依次弹出即可</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240718150806487.png" alt="image-20240718150806487"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断优先级</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">precedence</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">InfixToPostfix</span><span class="params">(string infix)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; operators;</span><br><span class="line">    string postfix = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; infix.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = infix[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            <span class="comment">// 将多位数作为一个整体处理</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; infix.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(infix[i])) &#123;</span><br><span class="line">                postfix += infix[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--; <span class="comment">// 回退一步，因为外层循环还会再增加一次</span></span><br><span class="line">            postfix += <span class="string">&#x27; &#x27;</span>; <span class="comment">// 在数字后面添加空格，以分隔数字</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//正常情况下中缀表达式不需要使用括号，出现了就忽略即可 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!operators.<span class="built_in">empty</span>() &amp;&amp; operators.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                postfix += operators.<span class="built_in">top</span>();</span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">pop</span>(); <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新操作符的优先级小于等于栈顶操作符-&gt;栈顶弹出</span></span><br><span class="line">            <span class="comment">//新操作符的优先级大于栈顶操作符    -&gt;压入</span></span><br><span class="line">            <span class="keyword">while</span> (!operators.<span class="built_in">empty</span>() &amp;&amp; operators.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; <span class="built_in">precedence</span>(c) &lt;= <span class="built_in">precedence</span>(operators.<span class="built_in">top</span>())) &#123;</span><br><span class="line">                postfix += operators.<span class="built_in">top</span>();</span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!operators.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        postfix += operators.<span class="built_in">top</span>();</span><br><span class="line">        operators.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postfix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中缀-&gt;前缀</p><p>具体流程和上文中缀-&gt;后缀的算法类似，只需要保证在弹出操作符的时候，将操作符加在表达式的最前方</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">InfixToPrefix</span><span class="params">(string infix)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt;operators;</span><br><span class="line">    string prefix = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;infix.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">char</span> c = infix[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;infix.<span class="built_in">length</span>() &amp;&amp; <span class="built_in">isdigit</span>(infix[i]))&#123;</span><br><span class="line">                prefix +=infix[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">//单引号，因为要添加是字符不是字符串</span></span><br><span class="line">            prefix +=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(operators.<span class="built_in">top</span>()!=<span class="string">&#x27;(&#x27;</span> &amp;&amp; !operators.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                prefix = operators.<span class="built_in">top</span>()+prefix;<span class="comment">//接在前面</span></span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//弹出直到能够压入</span></span><br><span class="line">            <span class="keyword">while</span>(!operators.<span class="built_in">empty</span>()&amp;&amp; <span class="built_in">precedence</span>(operators.<span class="built_in">top</span>())&gt;=<span class="built_in">precedence</span>(c))&#123;</span><br><span class="line">                prefix = operators.<span class="built_in">top</span>()+prefix;<span class="comment">//接在前面</span></span><br><span class="line">                operators.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            operators.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!operators.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        prefix = operators.<span class="built_in">top</span>()+prefix;<span class="comment">//接在前面</span></span><br><span class="line">        operators.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列Queues"><a href="#队列Queues" class="headerlink" title="队列Queues"></a>队列Queues</h2><h3 id="ADT-1"><a href="#ADT-1" class="headerlink" title="ADT"></a>ADT</h3><p>First-In-First-Out</p><p>定义：A list or collection with the restriction that isertion can be performed at one end (rear) and deletion can be performed at other end (front)</p><p>队尾进，队头出</p><p>operations:</p><p>EnQueue&#x2F;push :从队尾插入元素</p><p>DeQueue&#x2F;pop : 从队首移出元素</p><p>front&#x2F;peek: 返回队首元素</p><p>IsEmpty：查看是否为空</p><p>时间复杂度都是O（1）</p><p><u>栈是一段开口的容器，队列就是两端开口的容器</u></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719090231956.png" alt="image-20240719090231956"></p><p>下面将给出两种简单的实现方式</p><p>ps：C++标准库中的<code>queue</code>模板类通常使用双端队列（<code>deque</code>）作为其底层容器，而不是数组或链表。</p><h3 id="数组实现-1"><a href="#数组实现-1" class="headerlink" title="数组实现"></a>数组实现</h3><p>规定一个数组的某一边为front，另一边为rear</p><p>用变量记录这两个位置的索引，黄色的范围就是队列的范围，其他部分备用</p><p>用数组实现队列有一个有趣的现象，如果规定左侧为front，右侧为rear，可以发现队列会一直向右侧移动</p><p>如果想要最大化使用数组的内存，可以利用<strong>循环数组</strong>的概念</p><p>此时current position &#x3D; i, next position &#x3D;(i+1)%N, prv position &#x3D; (i+N-1)%N,这样一直增加i，就可以不断循环遍历数组的每一个位置，如果使用<strong>循环数组</strong>，那么队列满的条件是：</p><p>(rear+1)%N&#x3D;front，即使rear的下一位就是front</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719104359815.png" alt="image-20240719104359815"></p><p>以下代码没有使用循环数组</p><p>但是利用了动态数组，在队列满了以后，会创建一个两倍原大小的新数组用于存放队列</p><p>使用先需要先调用init 函数进行初始化</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queues</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> * A;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> front =<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> rear  =<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="type">int</span>[x];</span><br><span class="line">        size = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            front = rear = <span class="number">0</span>;</span><br><span class="line">            A[rear] = x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//满</span></span><br><span class="line">        <span class="keyword">if</span> (rear == size) &#123;</span><br><span class="line">            <span class="built_in">QueueIsFull</span>();</span><br><span class="line">            rear++;</span><br><span class="line">            A[rear] = x;</span><br><span class="line">            <span class="keyword">return</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        A[rear] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            front = rear = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放回队首元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="number">-1</span> &amp;&amp; rear == <span class="number">-1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: Queue is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[rear];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理数组满了的情况</span></span><br><span class="line">    <span class="comment">//无需手动调用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">QueueIsFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最坏的情况是原数组的所有位置都填满了</span></span><br><span class="line">        <span class="type">int</span> newSize = <span class="number">2</span> * (size);</span><br><span class="line">        <span class="type">int</span>* B = <span class="keyword">new</span> <span class="type">int</span>[newSize];</span><br><span class="line">        <span class="type">int</span> temp = front;</span><br><span class="line">        <span class="type">int</span> lengh = rear - front;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lengh; i++) &#123;</span><br><span class="line">            B[i] = A[temp];</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        A = B;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = lengh;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = front; i &lt;= rear; i++) &#123;</span><br><span class="line">            cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queues q1;</span><br><span class="line">    q1.<span class="built_in">init</span>(<span class="number">5</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    q1.<span class="built_in">pop</span>();</span><br><span class="line">    q1.<span class="built_in">Print</span>();<span class="comment">// 2 3 4 5 </span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">121</span>);</span><br><span class="line">    q1.<span class="built_in">push</span>(<span class="number">50000</span>);<span class="comment">//满了</span></span><br><span class="line">    q1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="comment">//2 3 4 5 121 50000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表实现-1"><a href="#链表实现-1" class="headerlink" title="链表实现"></a>链表实现</h3><p>正常的链表只需要一个head记录头节点的地址就可以</p><p>这里需要再加上一个rear指针记录最后一个节点的地址</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719131429378.png" alt="image-20240719131429378"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queues</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node * next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* front = <span class="literal">NULL</span>;</span><br><span class="line">    Node * rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        Node * temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        temp-&gt;data = x;</span><br><span class="line">        temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span> &amp;&amp; rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            front = rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队尾进</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rear-&gt;next = temp;</span><br><span class="line">            rear = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队头出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(front == rear)&#123;</span><br><span class="line">            <span class="keyword">delete</span> front;</span><br><span class="line">            front = rear = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node * temp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Error: queues is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> front-&gt;data; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Error: queues is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> rear-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node * temp = front;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树tree"><a href="#树tree" class="headerlink" title="树tree"></a>树tree</h2><h3 id="ADT-2"><a href="#ADT-2" class="headerlink" title="ADT"></a>ADT</h3><p>是一种层级结构（非线性）</p><p>是多个节点的集合，最高的节点称之为<strong>根</strong>（root）</p><p>各节点的关系：</p><p><strong>parent</strong> <strong>children</strong> <strong>sibling</strong><strong>ancenstor</strong>(例如节点1是所有节点的祖先) <strong>descendent</strong> <strong>cousin</strong></p><p>没有子节点的节点称为<strong>叶</strong>（leaf）</p><p>N个节点的树，有N-1条边（edge）因为每个节点（除了root）都只有一条传入的边</p><p><strong>depth</strong>：length of path from root to x 例如节点5的深度为2</p><p><strong>层级</strong>：深度为2，可以称为level-2(L-2），root 为level-0（L-2）</p><p><strong>Height</strong>：No. of edges in longest path from x to a leaf例如节点3的高度是2，leaf的高度是0</p><p>height of tree：就是root的height，下面这棵树的高度是3</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719134607138.png" alt="image-20240719134607138"></p><p><strong>Binary Tree</strong>：树中的每个节点至多有两条传出的边</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240719135927990.png" alt="image-20240719135927990"></p><p>应用：</p><p>1)天然具备层级的数据，例如磁盘驱动器的文件系统</p><p>2)快速查找、插入、删除</p><p>3)动态的拼写检查</p><p>4)网络路由算法</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个节点最多有两个孩子，一个称为left-child 另一个称为right-child</p><p><strong>严格二叉树</strong>strict&#x2F;proper binary tree：每个节点要么有两个孩子，要么有0个孩子</p><p><strong>完全二叉树</strong>Complete Binary tree: 叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。（<strong>满二叉树</strong>perfect Binary tree是特殊的完全二叉树）</p><p>第i层的最大节点数为2^i, 总最大节点数为2^(h+1)-1,其中h是二叉树的深度&#x2F;高度</p><p>换句话说,完全二叉树深度 h&#x3D;log2 (n+1)-1 &#x3D; log2(n) 向下取整</p><p><strong>平衡二叉树</strong> Balanced binary tree ：每一个节点的左子树和右子树的高度差不超过K（mostly 1)</p><p>定义平衡二叉树是因为有时我们不希望一棵树的高度太高</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>1、结构体实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node * left;</span><br><span class="line">Node * right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、数组实现</p><p>这种方法<strong>只对完全二叉树成立</strong></p><p>将节点编号后存放入数组（编号就是在数组中的索引）</p><p>对于索引为i的节点，其左孩为的索引为：2i+1,右孩为2i+2</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240720122748165.png" alt="image-20240720122748165"></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h4 id="ADT-3"><a href="#ADT-3" class="headerlink" title="ADT"></a>ADT</h4><p>适用于数据的快速搜索与更新</p><p>如果我们使用数组，查找的时间复杂度：O(n)，插入O(1),删除O(n),同时如果插入的数据超过了数组的容量，需要重新创建一个数组，成本是O(n)</p><p>如果使用链表：查找：O(n),插入（假设在链表头插入）O(1),删除O(n)</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240720124148440.png" alt="image-20240720124148440"></p><p>利用数组<strong>二分查找</strong>的时间复杂度： O（logn）</p><p>解释：</p><p>进行k次查找操作后，搜索范围将缩小到原来的一半的k次方，即n&#x2F;2^k。当n&#x2F;2 ^k小于等于1时，即k大于等于log2(n)，搜索范围将缩小到1，即找到了目标元素或搜索范围为空。所以，二分查找的时间复杂度为O(log n)，其中n是数组的长度。</p><p>但是这要求每次插入数据都要保证顺序，也就是说倒是Insert的时间复杂度（如果insert也采用二分查找）<strong>找到插入位置</strong>的时间复杂度为O(logn)，而<strong>插入数据</strong>的时间复杂度为O(n)</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240720125308635.png" alt="image-20240720125308635"></p><p>假如每秒可以进行100万次计算，即1次比较耗时：10^-6s （1微秒）</p><p>那么对于2^31个长度的数据，查找一个数据只需要 31微秒</p><p>如果用普通的数组&#x2F;链表去查询，查找会可能花费超过2000秒</p><p><strong>BST——Binary Search Tree</strong></p><p>BST的三个操作的时间成本都是O(log n)</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240720130041411.png" alt="image-20240720130041411"></p><p><strong>BST的定义：</strong></p><p>任一节点均不小于其左<strong>后代</strong>，且不大于其右<strong>后代</strong></p><p>注意这里的要求是“<strong>后代</strong>”而<strong>不是</strong>孩子</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/v2-50d1b50e9048325020d17ae6b990f61a_r.jpg" alt="img"></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240720130327841.png" alt="image-20240720130327841"></p><p>如果将上图的12改为16，那么对于value为15的根节点来说，其有一个左后代比它大，这就不是一颗二叉搜索树</p><p><strong>查找过程（search）：</strong></p><p>先比较目标数据与root的大小，如果小，就到左子树中查找，大就到右子树</p><p>重复这个过程，直到找到与目标数据相等的节点</p><p>每次查找，都会丢弃一半的查找范围，n-&gt;n&#x2F;2-&gt;n&#x2F;4……</p><p>n&#x2F;2^k &lt;&#x3D; 1 时， k&gt;&#x3D;log2(n),即该操作的<strong>时间复杂度为O(logn)</strong></p><p>其实这也是一种二分查找，当然，这要求二分搜索树是<strong>平衡</strong>的</p><p><strong>插入过程（insert）：</strong></p><p>重复查找过程，直到某节点的左孩&#x2F;右孩有空位</p><p>查找过程耗费**O(log n)**，创建节点并连接只耗费常数时间</p><p><strong>删除过程（remove）：</strong></p><p>同样的，查找到位置**O(log n)**，删除节点并重新连接只耗费常数时间</p><p><strong>上述三个过程中的递归调用次数与深度h正相关，也就是说空间复杂度为O(h)</strong></p><p><strong>最差情况下的空间复杂度为O(n)</strong></p><p><strong>平均情况&#x2F;最好情况下的空间复杂度为O(log(n))</strong></p><p><strong>C++的STL的set库&#x2F;map库的底层是自平衡的二叉搜索树（红黑树）</strong></p><p>红黑树是一种自平衡的二叉搜索树，它通过旋转和重新着色等操作来保持树的平衡，从而保证最坏情况下的时间复杂度为O(log n)。而BST可能是不平衡的，在最坏情况下，时间复杂度为O(n)。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下代码中的check是为了在第一次调用递归函数的时候将局部变量的数值赋值为树的根，这样写是因为我将root和各种接口都封装在了一个类中，这种写法并不常见</p><p>更常见的写法是在调用函数的时候直接传入root，即Search(100,root)，这样就不需要利用check赋初值</p><h5 id="Search-Insert-Remove"><a href="#Search-Insert-Remove" class="headerlink" title="Search&#x2F;Insert&#x2F;Remove"></a>Search&#x2F;Insert&#x2F;Remove</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node* left;</span><br><span class="line">        Node* right;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> check = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//查找函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Search</span><span class="params">(<span class="type">int</span> x, Node* root = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋初值</span></span><br><span class="line">        <span class="keyword">if</span> (check == <span class="number">0</span>) &#123;</span><br><span class="line">            root = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">            check++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            check--; <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == root-&gt;data) &#123;</span><br><span class="line">            check--; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">Search</span>(x, root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Search</span>(x, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//插入函数</span></span><br><span class="line">    <span class="function">Node* <span class="title">Insert</span><span class="params">(<span class="type">int</span> x, Node* root = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;root = <span class="built_in">GetNewNode</span>(x);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋初值</span></span><br><span class="line">        <span class="keyword">if</span> (check == <span class="number">0</span>) &#123;</span><br><span class="line">            root = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">            check++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root = <span class="built_in">GetNewNode</span>(x);</span><br><span class="line">            check--; <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= root-&gt;data) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">Insert</span>(x, root-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;data) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">Insert</span>(x,root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除函数</span></span><br><span class="line">    <span class="function">Node*  <span class="title">Remove</span><span class="params">(<span class="type">int</span> x, Node* root = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋初值</span></span><br><span class="line">        <span class="keyword">if</span> (check == <span class="number">0</span>) &#123;</span><br><span class="line">            root = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">            check++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            check--; <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找的过程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;data) &#123;</span><br><span class="line">            root-&gt;left=<span class="built_in">Remove</span>(x, root-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;data) &#123;</span><br><span class="line">            root-&gt;right=<span class="built_in">Remove</span>(x, root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Remove函数容易存在的问题：</span></span><br><span class="line">        <span class="comment">//用指针A将目标对应的内存释放掉了，但是node-&gt;left却成为了野指针</span></span><br><span class="line">        <span class="comment">//因此将NULL放回给上一个node的对应left/right指针是很有必要的</span></span><br><span class="line">        <span class="comment">// 也就是所Remove函数的放回类型应该是Node*而不是void </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//case 1: no child</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">                check--; <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//case 2: one child</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Node* temp = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                check--; <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Node* temp = root;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                check--; <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//case 3: two child</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将右子树中最小的数值作为root的新数值（因为这个数字满足BST需要的条件）   </span></span><br><span class="line">                <span class="comment">//使用左子树的最大值也可以</span></span><br><span class="line">                root-&gt;data = <span class="built_in">FindMin</span>(root-&gt;right);</span><br><span class="line">                root-&gt;right = <span class="built_in">Remove</span>(<span class="built_in">FindMin</span>(root-&gt;right), root-&gt;right);</span><br><span class="line">                check--; <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找一颗树的最小值的函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindMin</span><span class="params">(Node* temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Empty tree&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">GetNewNode</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        temp-&gt;data = x;</span><br><span class="line">        temp-&gt;left = temp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//show 第二层的右节点（测试用）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ShowL2_right</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node * temp =<span class="keyword">this</span>-&gt;root;</span><br><span class="line">        temp = temp-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BST bst;</span><br><span class="line">    bst.<span class="built_in">Insert</span>(<span class="number">5</span>);</span><br><span class="line">    bst.<span class="built_in">Insert</span>(<span class="number">100</span>);</span><br><span class="line">    bst.<span class="built_in">Insert</span>(<span class="number">66</span>);</span><br><span class="line">    bst.<span class="built_in">Insert</span>(<span class="number">330</span>);</span><br><span class="line">    bst.<span class="built_in">Insert</span>(<span class="number">120</span>);</span><br><span class="line">    cout &lt;&lt; bst.<span class="built_in">Search</span>(<span class="number">120</span>) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; bst.<span class="built_in">Search</span>(<span class="number">66</span>) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; bst.<span class="built_in">Search</span>(<span class="number">330</span>) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; bst.<span class="built_in">Search</span>(<span class="number">121</span>) &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">    <span class="comment">//          5</span></span><br><span class="line">    <span class="comment">//         &lt;--&gt;100</span></span><br><span class="line">    <span class="comment">//          66 &lt;-&gt;330</span></span><br><span class="line">    <span class="comment">//             120&lt;-    </span></span><br><span class="line">    bst.<span class="built_in">Remove</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; bst.<span class="built_in">Search</span>(<span class="number">100</span>) &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">    cout&lt;&lt;bst.<span class="built_in">ShowL2_right</span>()&lt;&lt;endl;<span class="comment">//120</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//          5</span></span><br><span class="line">    <span class="comment">//         &lt;--&gt;120</span></span><br><span class="line">    <span class="comment">//          66 &lt;-&gt;330</span></span><br></pre></td></tr></table></figure><h5 id="FindMin"><a href="#FindMin" class="headerlink" title="FindMin"></a>FindMin</h5><p>函数的递归写法：</p><p>时间复杂度O(log n)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_Min</span><span class="params">(Node * temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Empty tree&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find_Min</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="FindHeight"><a href="#FindHeight" class="headerlink" title="FindHeight"></a>FindHeight</h5><p>获得二叉树的高度</p><p>算法：一颗树的高度&#x3D;MAX（左右子树的高度）+1</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个点都遍历一次，时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindHeight</span><span class="params">(Node * root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//退出条件</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//empty的高度为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> LeftHeight = <span class="built_in">FindHeight</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rightHeight = <span class="built_in">FindHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(LeftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="IsBinarySearchTree"><a href="#IsBinarySearchTree" class="headerlink" title="IsBinarySearchTree"></a>IsBinarySearchTree</h5><p>判断是否为二叉搜索树</p><p>算法1（不推荐）：</p><p>根据定义，要求对于每一个节点，其大于等于自己左子树中的最大点，小于等于自己在右子树中的最小点，同时其左子树和右子树也是二叉搜索树</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(BST::Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">if</span>( </span><br><span class="line">       ( root-&gt;left == <span class="literal">NULL</span> || <span class="built_in">find_max</span>(root-&gt;left)&lt;= root-&gt;data )</span><br><span class="line">       &amp;&amp;</span><br><span class="line">       ( root-&gt;right == <span class="literal">NULL</span> || <span class="built_in">find_min</span>(root-&gt;right)&gt;= root-&gt;data )</span><br><span class="line">       &amp;&amp;</span><br><span class="line">       <span class="built_in">IsBinarySearchTree</span>(root-&gt;left)</span><br><span class="line">       &amp;&amp;</span><br><span class="line">       <span class="built_in">IsBinarySearchTree</span>(root-&gt;right)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法2：</p><p>根据父节点的数值确定子节点数值的方位，逐一判断</p><p>这个方法，每个节点只需要遍历1次，时间复杂度O(n)</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240721210802341.png" alt="image-20240721210802341"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(BST::Node * root,<span class="type">int</span> minValue=INT_MIN,<span class="type">int</span> maxValue=INT_MAX)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DLR</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data &gt;=minValue</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        root-&gt;data&lt;=maxValue</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        <span class="built_in">IsBinarySearchTree</span>(root-&gt;left,minValue,root-&gt;data)</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        <span class="built_in">IsBinarySearchTree</span>(root-&gt;right,root-&gt;data,maxValue)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中INT_MAX是最大的int类型数据，而INT_MIN则是最小的int类型数据</p><p>效果展示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//          5</span></span><br><span class="line"> <span class="comment">//         &lt;--&gt;120</span></span><br><span class="line"> <span class="comment">//          66 &lt;-&gt;330</span></span><br><span class="line"> bst.root-&gt;left-&gt;data=<span class="number">81</span>;</span><br><span class="line"> cout&lt;&lt;<span class="built_in">IsBinarySearchTree</span>(bst.root);<span class="comment">//0</span></span><br></pre></td></tr></table></figure><h3 id="Tree-Traversal遍历"><a href="#Tree-Traversal遍历" class="headerlink" title="Tree Traversal遍历"></a>Tree Traversal遍历</h3><p>process or visiting each node in the tree exactly once in some order</p><p><strong>breadth-first 广度优先</strong></p><p>每一层的节点都遍历完了以后，再到下一个节点</p><p>这种遍历称为<strong>层次遍历</strong></p><p><strong>Depth-first 深度优先</strong></p><p><strong>将一个子树全部遍历完以后，再到下一棵子树</strong>，这个特点可以用递归很好地实现</p><p>根据遍历的相对顺序的不同，可以分为前序&#x2F;中序&#x2F;后序遍历</p><p>例如前序遍历（preorder)就是的访问顺序为：root left right</p><p>也可以称为<strong>DLR</strong>，D就是data，LR表示方向</p><h4 id="二叉树层次遍历-代码实现"><a href="#二叉树层次遍历-代码实现" class="headerlink" title="二叉树层次遍历-代码实现"></a>二叉树层次遍历-代码实现</h4><p>算法：利用队列FIFO(first in first out)的性质<br>让root进入队列，然后当root出队列时，依次让其左孩和右孩进入队列</p><p>而当每个节点出队列时，执行相同操作，这样就按照从左往右的顺序实现了一次遍历</p><p>每个节点都被访问了一次，<strong>时间复杂度O(n)</strong></p><p>如果是满二叉树,<strong>空间复杂度O(n)</strong> &#x2F;&#x2F;最下层的节点数约等于n&#x2F;2</p><p>这也是平均场景下的空间复杂度</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Levelorder</span><span class="params">(BST::Node * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    queue&lt;BST::Node*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        BST::Node * temp = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>( temp-&gt;left != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>( temp-&gt;right != <span class="literal">NULL</span>) Q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        cout&lt;&lt;temp-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//          5</span></span><br><span class="line"><span class="comment">//        4&lt;--&gt;100</span></span><br><span class="line"><span class="comment">//      3&lt;-  66 &lt;-&gt;330</span></span><br><span class="line"><span class="comment">//             120&lt;-</span></span><br><span class="line"><span class="comment">//          101&lt;-  </span></span><br></pre></td></tr></table></figure><p>的遍历结果为：</p><p>5 4 100 3 66 330 120 101 </p><h4 id="二叉树前序-中序-后序遍历-代码实现"><a href="#二叉树前序-中序-后序遍历-代码实现" class="headerlink" title="二叉树前序&#x2F;中序&#x2F;后序遍历-代码实现"></a>二叉树前序&#x2F;中序&#x2F;后序遍历-代码实现</h4><p>前序遍历DLR</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Preorder</span><span class="params">(BST::Node * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;root-&gt;data&lt;&lt;endl;<span class="comment">//D</span></span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;left);<span class="comment">//L</span></span><br><span class="line">    <span class="built_in">Preorder</span>(root-&gt;right);<span class="comment">//R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历LDR</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(BST::Node * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;left);<span class="comment">//L</span></span><br><span class="line">    cout&lt;&lt;root-&gt;data&lt;&lt;endl;<span class="comment">//D</span></span><br><span class="line">    <span class="built_in">Inorder</span>(root-&gt;right);<span class="comment">//R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历LRD</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postorder</span><span class="params">(BST::Node * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;left);<span class="comment">//L</span></span><br><span class="line">    <span class="built_in">Postorder</span>(root-&gt;right);<span class="comment">//R</span></span><br><span class="line">        cout&lt;&lt;root-&gt;data&lt;&lt;endl;<span class="comment">//D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，对于二叉树：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//          5</span></span><br><span class="line"><span class="comment">//        4&lt;--&gt;100</span></span><br><span class="line"><span class="comment">//      3&lt;-  66 &lt;-&gt;330</span></span><br><span class="line"><span class="comment">//             120&lt;-</span></span><br><span class="line"><span class="comment">//          101&lt;-  </span></span><br></pre></td></tr></table></figure><p>三种遍历方式的结果为：</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240721114343583.png" alt="image-20240721114343583"></p><p>这三种算法的时间复杂度都是O(n)</p><p>空间复杂度O(h),其中h是树的高度</p><p>最差情况下的空间复杂度为O(n)&#x2F;&#x2F;类似于链表的树</p><p>最好情况&#x2F;平均情况的空间复杂度为O(log(n))</p><p>这里的空间复杂度是因为<strong>递归调用</strong>产生的，空间成本看的是<strong>最多同时占据栈区中的几个栈帧</strong></p><h4 id="中序后继节点"><a href="#中序后继节点" class="headerlink" title="中序后继节点"></a>中序后继节点</h4><p>Inorder Successor</p><p>中序遍历有个特点：</p><p>访问的数据严格按照从小到大排列</p><p>有时候我们需要找到树比某个数值大的下一个数据</p><p>也就是要找到这个节点的中序后继节点</p><p>如果我们直接采用中序遍历去找，当然可以找到，但是这个时间复杂度是O(n)</p><p>这个开销还是比较大的，因此我们需要更快捷的算法：</p><p><strong>case1</strong>: 当前节点有right child，中序后继节点就是findmin(right child)&#x2F;&#x2F;返回Node*</p><p><strong>case2</strong>:当前节点没有right child,</p><p>如果当前节点是其父节点的left child中序后继节点就是就是其父节点</p><p>如果当前节点是其父节点的right child,中序后继节点就是其最近的祖先，而且这个祖先还要满足：目标节点在其左子树中</p><p>也就是说，这两种情况可以统一为：*<strong>找到最近的将目标节点包含在左子树中的祖先</strong></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BST::Node * <span class="title">GetSuccessor</span><span class="params">(BST::Node*root,<span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先确定当前节点的位置</span></span><br><span class="line">    BST::Node* current = <span class="built_in">Search</span>(data,root);</span><br><span class="line">    <span class="keyword">if</span>(current == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定最近的将目标节点包含在左子树中的祖先</span></span><br><span class="line">    <span class="comment">//case 1: has right subtree</span></span><br><span class="line">    <span class="keyword">if</span>(current-&gt;right !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST::Node* temp = current-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;left != <span class="literal">NULL</span>) temp = temp-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//case 2: no right subtree</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST::Node * successor = <span class="literal">NULL</span>;<span class="comment">//中序后继节点</span></span><br><span class="line">        BST::Node * ancestor = root;</span><br><span class="line">        <span class="keyword">while</span>(current-&gt;data != ancestor-&gt;data )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当current 在ancestor的左子树中时</span></span><br><span class="line">            <span class="keyword">if</span>(current-&gt;data &lt; ancestor-&gt;data)&#123;</span><br><span class="line">                successor = ancestor;</span><br><span class="line">                ancestor = ancestor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ancestor = ancestor-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最差的情况下，进行两次时间复杂度为O(log n)的查找</p><p>也就是说，这个算法的时间复杂度为O(log n) </p><p>当n的数目极大的时候，这个算法会明显由于前文提到的直接用中序遍历寻找的方法</p><h2 id="图graphs"><a href="#图graphs" class="headerlink" title="图graphs"></a>图graphs</h2><h3 id="ADT："><a href="#ADT：" class="headerlink" title="ADT："></a>ADT：</h3><p>边可以以任意方式链接节点</p><p>定义: A graoh G is an ordered pair of a set V of vertices and a set E of edges </p><p>一个图G包含边集V和点集E，可以写成G(V,E)  &#x2F;&#x2F;(V,E)有序对</p><p><strong>边的表示</strong>：</p><p>有向(directed edge)： (u,v) !&#x3D; (v,u)</p><p>无向(undirected edge) {u,v} </p><p><strong>图的分类</strong>:所有边都有方向:a directed graph &#x2F; Digraph</p><p>所有边都没有方向: an undirected graph</p><p><strong>应用：</strong>好友关系可以用无向图，关注关系可以用有向图</p><p>链接的跳转可以用有向图， web-crawling（网络爬虫）本质上就是图的遍历（graph traversal)</p><p><strong>加权图</strong>：</p><p>每条edge都有数值，例如可以用数值表示道路的长度</p><h3 id="图的特性"><a href="#图的特性" class="headerlink" title="图的特性:"></a>图的特性:</h3><p><strong>自环(self-loop)</strong></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722100718879.png" alt="image-20240722100718879"></p><p><strong>多重边(multiedge)</strong></p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722100934574.png" alt="image-20240722100934574"></p><p><strong>简单图(simple graph)</strong></p><p>没有多重边和自环的图</p><p>一个有向简单图的最大边数为 (n-1)*n</p><p>一个无向简单图的最大边数 (n-1)*n&#x2F;2</p><p><strong>Dense(稠密)-too many edges</strong></p><p><strong>Sparse(稀疏)-too few edges</strong></p><p><strong>路径(Path)</strong></p><p>简单路径(simple path)经过的节点和边都不重复</p><p>通常我们说path 的时候指的就是simple path</p><p>而常用<strong>walk</strong>指一般的路径</p><p>**强连接(strongly connected **</p><p>定义：if there is a path from any vertex to any vertex</p><p><strong>弱连接图(weakly connected)</strong></p><p>如果将一个非强连接图中的directed edge 改成 undirected edge 就变成强连接</p><p>那么这个图就是弱连接</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722102612481.png" alt="image-20240722102612481"></p><p><strong>closed walk</strong></p><p>闭合路径，要求起点和重点是同一个vertex</p><p><strong>simple cycle</strong></p><p>起点和终点的顶点访问两次，其他顶点和边不重复访问的闭合路径</p><p>常用cycle 代表 simple cycle</p><p><strong>Acyclic graph(无环图)</strong></p><p>没有简单循环的图的图</p><h3 id="图的表示法"><a href="#图的表示法" class="headerlink" title="图的表示法"></a>图的表示法</h3><h4 id="边列表"><a href="#边列表" class="headerlink" title="边列表"></a>边列表</h4><p>可以用动态列表实现，例如C++中的Vector</p><p>一个list存放vertex，一个list存放edge</p><p>edge可以用struct定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="comment">//starVertex&amp;endVertex代表对应节点在vertex list中的索引</span></span><br><span class="line"><span class="type">int</span> starVertex;</span><br><span class="line"><span class="type">int</span> endVertex;</span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//加权</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722135215800.png" alt="image-20240722135215800"></p><p>从空间复杂度来看，边列表的开销不算大</p><p>对于一个图，最频繁的执行的操作是找到一个点的邻接点，这个操作的<strong>时间复杂度为O(|E|)</strong></p><p>另一个操作是查看给定的两个点是否相连,具体算法是从起点开始，让每一条walk走到底（直到没有点&#x2F;发生循环为止)这个操作的<strong>时间复杂度为O(|E|)</strong></p><p>对于一个有向简单图,E&lt;&#x3D;V*(V-1)&#x2F;2,这个时间复杂度的开销还是比较大的</p><p><strong>如果一个图是稀疏的，那么就适合用边列表</strong></p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>我们需要用一个二维矩阵代替原来的edge list </p><p>二维矩阵的一个元素可以表示为Aij，矩阵的数据类型是int&#x2F;bool</p><p>如果从点i到点j有edge，那么Aij就等于1，如果这条边是无向的，那么Aji也为1</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722140801342.png" alt="image-20240722140801342"></p><p>空间复杂度O(|V|)、O（|V|*|V|)</p><p>时间复杂度：</p><p><strong>找到邻接点：</strong>首先在vertex list 中找到这个数据的索引，O（V）</p><p>然后在数组中以这个索引为横坐标&#x2F;纵坐标找到邻接点，O(V)+O(V)</p><p><strong>总时间复杂度O（|V|）</strong></p><p><strong>判断两个节点是否连接:</strong></p><p>先根据节点的名字找到节点的索引，耗费O(V)</p><p>然后看Aij和Aji即可，时间复杂度O(1),<strong>总时间复杂度O(V)</strong></p><p>如果使用一个<strong>哈希表</strong>存储点的名字和索引的话，这个时间复杂度可以降到O(1)</p><p>如果图有<strong>权重</strong>，就可以把数组存储的数值改成边的权重</p><p>同时将数值的默认值设置为一个不可能出现的数值</p><p><strong>如果一个图是稠密的，那么就适合用邻接矩阵</strong></p><p>例如对于facebook，假设其有10^9用户，每个用户的好友不超过1000，那么边数： 10 ^9 * 10^3 &#x2F;2 &#x3D;5*10^11 &lt;&lt; 10^18</p><p>也就是说这个好友关系图是稀疏的，不应该用邻接矩阵，否则<strong>内存消耗太大</strong>了</p><p>当然了，Facebook用的也不是边列表，用的可能是<strong>邻接列表（Adjacency List）</strong></p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>现实生活中的大多数表是稀疏的，如果我们像邻接矩阵一样用一块内存保存两个相连节点的”不相连“关系，未免太过奢侈了</p><p>邻接列表的基本思想是：</p><p><strong>对于图中的每个节点，都维护一个列表，该列表包含与该节点相邻的所有其他节点。</strong></p><p>如果是有向图，那么列表中存储的是以该节点为起点的邻接点</p><p>同样的，这个列表存储的是节点在vertex list 中的索引</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722151022511.png" alt="image-20240722151022511"></p><p>在C++中，可以用指针数组实现一个这样的结构</p><p>相当于实现了一个每一行的大小都不一样的二维数组</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span> *&gt;v;<span class="comment">//整个列表</span></span><br><span class="line"><span class="type">int</span> * v0 = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">3</span>];   </span><br><span class="line">v.<span class="built_in">push_back</span>(v0);</span><br><span class="line">v0[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">v0[<span class="number">6</span>] = <span class="number">3</span>;</span><br><span class="line">v0[<span class="number">7</span>] = <span class="number">21</span>;</span><br></pre></td></tr></table></figure><p>空间复杂度O（V+E）,相比于邻接矩阵，空间耗费少了很多</p><p>判断两个点是否连接：时间复杂度O(d)，d代表节点的度数，假设已经通过键值对（哈希表）获得了两个节点的索引，只需要看第i行的数组是否有j以及第j行的数组中是否有i，这个<strong>时间复杂度是O(d)</strong>,D&lt;&#x3D;V</p><p>找到一个点的所有邻接节点：找到以该点为起点的邻接节点：O（d）</p><p>找到以该点为终点的邻接节点可能需要遍历邻接表中的所有元素，这个开销是很大的</p><p><strong>如果该图无向，时间复杂度为O(d)</strong></p><p>如果有向，我们得考虑让一个点维护两个数组，一个代表入度，一个代表出度，如果这个，<strong>时间复杂度仍为 O（d）</strong></p><p><strong>否则，时间复杂度为O(all)</strong>,all代表邻接表中的元素个数</p><p>相较于邻接矩阵，邻接表的最大优势是节省了大量空间，同时能够节省一部分时间，即使在时间复杂度上来看这并不明显，但是当V很大（例如10亿）时，如果用邻接表找邻接节点，需要扫描十亿次，而用邻接表，如果这个节点有1000个好友，那么也只需要扫描1000次</p><p>有时候，每个节点维护的列表不用动态数组实现，而用链表实现，这是因为链表在插入新数据的时候开销比数组小很多</p><p>在某些情况下，我们也会用二叉搜索树实现这个列表</p><p><img src="/2024/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240722224608478.png" alt="image-20240722224608478"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>学以致用，共勉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乌萨奇通讯录项目报告</title>
      <link href="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/"/>
      <url>/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/</url>
      
        <content type="html"><![CDATA[<h1 id="乌萨奇通讯录项目报告"><a href="#乌萨奇通讯录项目报告" class="headerlink" title="乌萨奇通讯录项目报告"></a>乌萨奇通讯录项目报告</h1><h2 id="设计背景："><a href="#设计背景：" class="headerlink" title="设计背景："></a><strong>设计背景：</strong></h2><p>在聊天软件（如微信）日益发达的今天，我们通过打电话联系他人的频率越来越低，这导致了我们可能会经常性地忘记某个朋友的电话或是邮箱账号。</p><p>在移动端已经有了成熟的通讯录app的基础上，乌萨奇通讯录的设计目的是在PC端为用户提供方便快捷的录入联系人信息的功能，以及强大的生日查询和邮件发送功能，满足现代人日益发展的社交需求。</p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a><strong>程序结构</strong></h2><p>本项目共有17个.h头文件，对应17个.cpp头文件以及14个.ui文件，由于界面文件较多，下面由界面的切换逻辑来对程序的结构进行讲解。</p><p>界面切换逻辑示意图：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103858409.png" alt="image-20240617103858409"></p><p>图中，带有“切换“字样的双箭头表明两个界面之间是来回切换的关系，但一个页面显示，另一个页面则会进行隐藏。</p><p>而单箭头表明从箭头的起点对应的页面可以产生箭头指向的页面，两个页面将会同时显示在屏幕上。</p><p>而从Email_func到Email_func_birth、Email_func_normal、Email_send_func的切换逻辑比较特殊，这里在Email_func页面制作了一个侧边栏的设计，可以通过三个按钮在三个页面间来回切换。</p><p>除了图中14个包含.ui文件的文件，本项目中还有四个文件，他们的功能如下：</p><p>|——mysound.h &#x2F;&#x2F;实现各种音效</p><p>|——contact.h &#x2F;&#x2F;包含一个基类和五个派生类，实现快速添加联系人</p><p>|——db_operator.h &#x2F;&#x2F;连接数据库</p><p>|——email.h &#x2F;&#x2F;封装一个函数，用于发送邮件</p><h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a><strong>程序功能</strong></h2><p>下面我将结合相应的界面对项目的功能进行说明，并会对该功能的实现方式进行简单的诠释。</p><p>主界面如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103921604.png" alt="image-20240617103921604"></p><h3 id="1、登录-注册功能："><a href="#1、登录-注册功能：" class="headerlink" title="1、登录&#x2F;注册功能："></a><strong>1、登录&#x2F;注册功能：</strong></h3><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103933469.png" alt="image-20240617103933469"></p><p>用户打开程序，最先显示的是左侧的登录界面，首先用户应该注册一个账户，注册界面如右图所示。</p><p>用户可以自由添加头像，图片中显示的是用户的默认头像，接着用户可以输入自己的用户名和密码（密码需要二次输入进行确认），点击“注册”后，程序会将用户的用户名和密码信息保存到数据库中，实现注册功能。</p><p>在具体的代码中，首先用</p><p>QString username &#x3D; ui-&gt;username_le-&gt;text();</p><p>QString pwd_1 &#x3D; ui-&gt;pwd_le1-&gt;text();</p><p>QString pwd_2 &#x3D; ui-&gt;pwd_le2-&gt;text();</p><p>获取用户输入的信息，接着用if语句用户输入是否为空以及两次输入的密码是否相同等内容。</p><p>重要的是会对数据库中是否已存在相同的用户名进行判定，判定代码如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617103948169.png" alt="image-20240617103948169"></p><p>若查询结果为空，表明不存在相同的用户名，下一步会进行图片的处理。</p><p>此处限定图片大小为15.9mb是因为数据库中用于存放图片数据的字段的数据类型为MEDIUNBLOB，其最大容量为15.9mb</p><p>此过程可以概括为将图片的二进制数据写入QByteArray 对象 photo_data后，用photo_data初始化QVariant对象 photo</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图片处理</span></span><br><span class="line">              QByteArray photo_data;</span><br><span class="line">              <span class="function">QBuffer <span class="title">buffer</span><span class="params">(&amp;photo_data)</span></span>;</span><br><span class="line">              buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">              <span class="keyword">this</span>-&gt;image.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;JPEG&quot;</span>,<span class="number">100</span>); <span class="comment">// 将图片的二进制数据写入photo_data</span></span><br><span class="line">              <span class="comment">// 检查图片数据大小</span></span><br><span class="line">              <span class="type">int</span> quality=<span class="number">90</span>;</span><br><span class="line">              <span class="keyword">while</span> (photo_data.<span class="built_in">size</span>() &gt; <span class="number">15.9</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">// 图片数据超过了最大允许大小</span></span><br><span class="line">                  <span class="comment">// 清空buffer</span></span><br><span class="line">                  buffer.<span class="built_in">setData</span>(<span class="built_in">QByteArray</span>());</span><br><span class="line">                  <span class="comment">// 重新保存 quality  逐渐降低</span></span><br><span class="line">                  image.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;JPEG&quot;</span>,quality);</span><br><span class="line">                  <span class="built_in">qDebug</span>()&lt;&lt; quality ;</span><br><span class="line">                  quality -= <span class="number">10</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="function">QVariant <span class="title">photo</span><span class="params">(photo_data)</span></span>;</span><br></pre></td></tr></table></figure><p>在获取了用户的信息后，对用户信息进行插入操作，对应代码如下：c</p><p>（此处的memo字段用于存放“便利贴”中的内容，在之后的“便利贴”功能讲解中会说明，这里先插入一个空字符串）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">QString memo  = <span class="string">&quot;&quot;</span>;</span><br><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;INSERT INTO accounts (user_name, password, photo,memo) VALUES (:username, :password,:photo,:memo)&quot;</span>);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:username&quot;</span>, username);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:password&quot;</span>, pwd_1);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:photo&quot;</span>, photo);</span><br><span class="line">query.<span class="built_in">bindValue</span>(<span class="string">&quot;:memo&quot;</span>, memo);</span><br><span class="line"><span class="keyword">if</span> (query.<span class="built_in">exec</span>())</span><br><span class="line">&#123;</span><br><span class="line">    sound.yaha.<span class="built_in">play</span>();</span><br><span class="line">    QMessageBox::<span class="built_in">information</span> (<span class="keyword">this</span>, <span class="string">&quot;注册&quot;</span>, <span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">    <span class="function">emit <span class="title">regist_ready</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注册成功后，用户便能够进行登录操作</p><p>点击登录按钮对应的槽函数的部分代码如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104017986.png" alt="image-20240617104017986">这段代码在数据库中查询是否存在对应用户名和密码的数据，接着将数据库中accounts表中的id（primary key)存储到变量user_id中。</p><h3 id="2、添加-修改-删除联系人信息功能"><a href="#2、添加-修改-删除联系人信息功能" class="headerlink" title="2、添加&#x2F;修改&#x2F;删除联系人信息功能"></a><strong>2、添加&#x2F;修改&#x2F;删除联系人信息功能</strong></h3><p>添加页面：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104043299.png" alt="image-20240617104043299"></p><p>添加页面的comboBox提供了四个默认分组以及“无”和“其他”的选项</p><p>如果选择“其他”就会让用户填写自定义的分组。</p><p>这个小功能的实现是利用了on_comboBox_activated这一个槽函数，这个槽函数会在comboBox的索引被修改的时候自动调用，当索引为5（对应“其他”）的时候ui-&gt;newtype_lb-&gt;setVisible(true);ui-&gt;newtype_le-&gt;setVisible(true)；</p><p>点击“添加联系人”按钮以后，在槽函数中，会执行对用户输入内容的检测、图片处理等，这一部分和上文登录&#x2F;注册功能中展示的代码类似，不再进行展示。</p><p>随后，利用switch语句，根据用户在comboBox中选择的索引，进行对应对象的创建，其中new_contact是Contact*类型对象，其他类均为Contact类的子类</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104052407.png" alt="image-20240617104052407"></p><p>Other_cot类的add_contact函数实现如下：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104102613.png" alt="image-20240617104102613"></p><p>这样就实现了联系人信息的添加。</p><p>添加成功后，关闭页面，就可以看到新添加的联系人已经出现在了主界面上，这里重写了add_func类的关闭事件</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104110431.png" alt="image-20240617104110431"></p><p>关闭页面后发出close（）信号，其与main_func对象的on_show()槽函数连接</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104205576.png" alt="image-20240617104205576"></p><p>其中show_cot代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QSqlQuery query;</span><br><span class="line">   query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT name, birth, phone, email, type, special_info FROM contacts WHERE user_id = :user_id&quot;</span>);</span><br><span class="line">   query.<span class="built_in">bindValue</span>(<span class="string">&quot;:user_id&quot;</span>, <span class="keyword">this</span>-&gt;user_id);</span><br><span class="line">   query.<span class="built_in">exec</span>();</span><br><span class="line">   <span class="comment">//qDebug()&lt;&lt; this-&gt;user_id;</span></span><br><span class="line">   <span class="keyword">this</span>-&gt;qmodel = <span class="keyword">new</span> <span class="built_in">QSqlQueryModel</span>(<span class="keyword">this</span>);</span><br><span class="line">   <span class="comment">//使用移动语义设置模型的数据</span></span><br><span class="line">   qmodel-&gt;<span class="built_in">setQuery</span>(std::<span class="built_in">move</span>(query));</span><br><span class="line">   <span class="comment">//ui-&gt;contact_table-&gt;setModel(qmodel);</span></span><br><span class="line"></span><br><span class="line">   ui-&gt;contact_table-&gt;<span class="built_in">setSortingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   QSortFilterProxyModel *sqlproxy = <span class="keyword">new</span> <span class="built_in">QSortFilterProxyModel</span>(<span class="keyword">this</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setSourceModel</span>(qmodel);</span><br><span class="line"></span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">0</span>, Qt::Horizontal, <span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">1</span>, Qt::Horizontal, <span class="string">&quot;生日&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">2</span>, Qt::Horizontal, <span class="string">&quot;电话号码&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">3</span>, Qt::Horizontal, <span class="string">&quot;邮箱&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">4</span>, Qt::Horizontal, <span class="string">&quot;分组&quot;</span>);</span><br><span class="line">   sqlproxy-&gt;<span class="built_in">setHeaderData</span>(<span class="number">5</span>, Qt::Horizontal, <span class="string">&quot;备注&quot;</span>);</span><br><span class="line"></span><br><span class="line">   ui-&gt;contact_table-&gt;<span class="built_in">setModel</span>(sqlproxy);</span><br></pre></td></tr></table></figure><p>这样就实现了页面切换+自动刷新，之后的页面切换功能都是采用类似的做法，不会再次讲解。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104521061.png" alt="image-20240617104521061"></p><p>在主界面，可以右键呼出菜单项，点击“查看”后，跳转到查看页面</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104527764.png" alt="image-20240617104527764"></p><p>在查看页面中，可以对输入框的内容进行修改，点击保存按钮后，即修改成功，保存按钮的槽函数和上文添加联系人功能的槽函数类似，都是检验格式+图片处理，只是第三步修改为了update语句，例如：UPDATE contacts SET name &#x3D; :name_change</p><p>这里不作详细展示。</p><p>有关利用菜单项切换页面的具体实现，会在“技术亮点”中进行讲解</p><p>删除功能：</p><p>实现流程是，根据索引值和model信息，获取鼠标点击位置的那一行的相关数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Modify_func::data_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> row = index.<span class="built_in">row</span>();</span><br><span class="line">    name = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">0</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    birth  = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">1</span>)).<span class="built_in">toDate</span>();</span><br><span class="line">    phone = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">2</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    email = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">3</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    type = model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">4</span>)).<span class="built_in">toString</span>();</span><br><span class="line">    special_info=model-&gt;<span class="built_in">data</span>(model-&gt;<span class="built_in">index</span>(row,<span class="number">5</span>)).<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着在数据库中进行查询</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT photo &quot;</span></span><br><span class="line">                  <span class="string">&quot;FROM contacts&quot;</span></span><br><span class="line">                  <span class="string">&quot; WHERE  name=:name AND  birth=:birth AND  phone=:phone AND email=:email AND type=:type AND special_info=:special_info AND user_id=:user_id &quot;</span>);</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:name&quot;</span>, name);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:birth&quot;</span>,  birth);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:phone&quot;</span>,  phone);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:email&quot;</span>,  email);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:type&quot;</span>,  type);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:special_info&quot;</span>, special_info);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:user_id&quot;</span>, <span class="keyword">this</span>-&gt;user_id);</span><br><span class="line">    query.<span class="built_in">exec</span>();</span><br><span class="line">    query.<span class="built_in">next</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后提取那一行的id（主键），然后用DELETE语句进行删除</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(query.<span class="built_in">next</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取contacts表中这一行数据的id</span></span><br><span class="line">        <span class="type">int</span> id = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;id;</span><br><span class="line">        <span class="comment">// 删除语句</span></span><br><span class="line">        QString deleteSql = <span class="built_in">QString</span>(<span class="string">&quot;DELETE FROM contacts WHERE id = %1&quot;</span>).<span class="built_in">arg</span>(id);</span><br><span class="line">        <span class="keyword">if</span>(query.<span class="built_in">exec</span>(deleteSql))<span class="comment">//删除</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;删除成功&quot;</span>;</span><br><span class="line">            emit <span class="keyword">this</span>-&gt;<span class="built_in">delete_ready</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、生日查询-祝福邮件发送功能"><a href="#3、生日查询-祝福邮件发送功能" class="headerlink" title="3、生日查询&#x2F;祝福邮件发送功能"></a><strong>3、生日查询&#x2F;祝福邮件发送功能</strong></h3><p>生日查询界面如下：</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104718253.png" alt="image-20240617104718253" style="zoom: 67%;"><p>左侧是三个按钮，可以实现页面切换，这里侧边栏的实现是通过stackedWidget实现</p><p>具体而言步骤为：</p><p>1、为Email_func的stackedWidget对象添加界面对象的地址</p><p>2、为每个按钮设定索引值</p><p>3、连接信号，将点击按钮传递的信号（包含索引值）与stackedWidget的setCurrentIndex函数连接，实现页面切换</p><p>这里没有将buttonClicked信号与setCurrentIndex函数直接连接，buttonClicked会传递一个QAbstractButton *类型的参数，与setCurrentIndex需要的参数类型（int）不匹配，所以写了一个适配器函数onButtonClicked进行辅助连接。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104739982.png" alt="image-20240617104739982"></p><p>适配器函数：<img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104748716.png" alt="image-20240617104748716"></p><p>年-月-日查询：</p><p>在最上方提供了三各QspinBox用于信息的输入，每个QspinBox都设定了范围</p><p>同时0作为一个默认值，代表所有，例如用户对0-0-0进行生日查询，会查询出所有联系人</p><p>如果对0-7-0进行查询，就可以查询任意年份+7月+任意日期过生日的联系人。</p><p>这个查询功能的实现方式将会在“难点攻破”中详细说明</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104759495.png" alt="image-20240617104759495"></p><p>近期生日查询：</p><p>在此页面中，同样用一个QspinBox进行信息的输入，范围设置为0-31</p><p>可以查询当天前后0-31天过生日的联系人，具体实现会在“技术亮点”中进行讲解</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104815721.png" alt="image-20240617104815721" style="zoom:67%;"><p>邮件发送功能：</p><p>在输入框中输入收件人的邮箱（可以在前两个页面查询的结果中直接复制，十分方便）</p><p>会自动匹配邮箱名对应的联系人姓名，并且显示在上方，同时自动修改正文开头</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104832710.png" alt="image-20240617104832710"></p><p>自动匹配姓名的代码如下：</p><p>这段代码在on_lineEdit_textChanged槽函数中实现（在line_edit中的内容被更改的时候调用此函数）</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104844452.png" alt="image-20240617104844452"></p><p>点击“发送邮件”有，跳转到邮箱登录界面：</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104854364.png" alt="image-20240617104854364" style="zoom:50%;"><p>这里要求用户填写邮箱的账号以及授权码（不是密码）需要用户去发送邮件的邮箱开通POP3&#x2F;SMTP服务</p><p>开通后，会得到一个授权码。</p><p>填写好邮箱和授权码，点击“登录此邮箱”就会进行一个邮件的发送。</p><p>点击按钮后，如果输入格式正确，email_login对象会发出一个email_login信号，这个信连接的槽函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里要小心多次连接问题</span></span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> check=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(check==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">connect</span>(email_login_page,&amp;email_login::login_ready,[=]()</span><br><span class="line">               &#123;</span><br><span class="line">                   QString  SenderEmail= email_login_page-&gt;account;</span><br><span class="line">                   QString SenderPassword = email_login_page-&gt;password;</span><br><span class="line"></span><br><span class="line">                   QRegularExpression <span class="built_in">regex</span>(<span class="string">&quot;^(.+)@(.+)$&quot;</span>);</span><br><span class="line">                   QRegularExpressionMatch match = regex.<span class="built_in">match</span>(SenderEmail);</span><br><span class="line">                   QString domain = match.<span class="built_in">captured</span>(<span class="number">2</span>);</span><br><span class="line">                   QString SmtpServer = <span class="string">&quot;smtp.&quot;</span>  +  domain;</span><br><span class="line">                   <span class="built_in">qDebug</span>()&lt;&lt;SmtpServer;</span><br><span class="line">                   QString ReceiveEmail=ui-&gt;lineEdit-&gt;<span class="built_in">text</span>();</span><br><span class="line">                   <span class="type">int</span> SmtpPort =<span class="number">25</span>;</span><br><span class="line">                   QString SubjectTitle=<span class="string">&quot;生日快乐！&quot;</span>;</span><br><span class="line">                   QString Content=ui-&gt;plainTextEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line"></span><br><span class="line">                   email.<span class="built_in">sendEmail</span>(  SmtpServer,  SmtpPort, SenderEmail,  SenderPassword,  ReceiveEmail,  SubjectTitle,  Content);</span><br><span class="line"></span><br><span class="line">               &#125;);</span><br><span class="line">       check++;</span><br><span class="line">   &#125;</span><br><span class="line">   email_login_page-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>这里采用正则表达式获取用户邮箱的@后面内容，&lt;例如<a href="mailto:&#120;&#x78;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#x78;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>&gt;，会获取“qq.com”,接着在qq前加上smtp.前缀，就是qq的smtp服务器smtp.qq.com，端口一般时25，接着将用于发送邮件的邮箱的邮箱名、授权码、收件邮箱的邮箱名、邮件标题（这里默认为“生日快乐！”）、邮箱正文（用户之前编辑的内容）作为sendEmail函数的参数，在sendEmail函数中实现邮件发送。在sendEmail函数中，采取TCP连接方式，用一个QTcpSocket对象的write函数向服务器发送信息，用readAll函数接收服务器发送回来的信息，由于此代码长度较长，而且重复的内容较多（基本上就是依次发送上方的七个参数的内容给服务器）这里只展示一个小片段：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104932783.png" alt="image-20240617104932783"></p><h3 id="4、搜索功能："><a href="#4、搜索功能：" class="headerlink" title="4、搜索功能："></a><strong>4、搜索功能：</strong></h3><p>在主界面的上方，有一个搜索框，可以对联系人信息进行搜索：</p><p>例如这里输入“境”出现了王境博和环境专业的乌萨奇</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104942257.png" alt="image-20240617104942257"></p><p>模糊搜索功能实现代码如下：</p><p>如果输入框中没有内容，这段代码还可以是实现刷新功能</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617104951215.png" alt="image-20240617104951215"></p><p>查询成功后，用query去初始化model，再用model去渲染tableview就可以显示查找结果。（上文有类似代码）</p><h3 id="5、用户信息修改功能："><a href="#5、用户信息修改功能：" class="headerlink" title="5、用户信息修改功能："></a><strong>5、用户信息修改功能：</strong></h3><p>点击用户头像会弹出来一个菜单项</p><p>“修改头像”、“注销账号”的功能与联系人的添加头像和删除类似，这里不再赘述</p><p>“修改用户名”和“修改密码”类似，这里以后者为例</p><p>点击按钮后，弹出一个修改密码界面，要求用户先输入原密码，再两次输入新密码，</p><p>如果两次输入的密码相同，就用UPDATE语句修改accounts表中id&#x3D;user_id处的password字段信息</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105005480.png" alt="image-20240617105005480"></p><p>注销账号页面如下：<br><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105013921.png" alt="image-20240617105013921" style="zoom:50%;"></p><p>退出登录功能：</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105028186.png" alt="image-20240617105028186" style="zoom: 67%;"><p>发送了一个exit_account信号，与Login类的on_show槽函数连接，退出登录后，将会返回到Login界面</p><h3 id="6、便利贴-备忘录"><a href="#6、便利贴-备忘录" class="headerlink" title="6、便利贴&#x2F;备忘录"></a><strong>6、便利贴&#x2F;备忘录</strong></h3><p>在主界面的左下角有一个便利贴功能，可以记录一下一些待办事项</p><p>便利贴（plainTextEdit）的样式设定为0.6的透明度</p><p>而一旦用户的鼠标悬停&#x2F;正在编辑plainTextEdit，就设定背景为黄色，方便用户看清内容（前文的搜索框也采用了类似的设计）</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105042851.png" alt="image-20240617105042851" style="zoom: 67%;"><p>便利贴信息存储在accounts表格的memo字段，在mainfunc的init中进行初始化，同时，在每个退出主界面的地方都设定了自动保存（例如点击头像-退出登录、直接点击页面右上角的关闭）这样就实现了自动保存，减少用户操作的繁琐性。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105101040.png" alt="image-20240617105101040"></p><h3 id="7、音效"><a href="#7、音效" class="headerlink" title="7、音效"></a><strong>7、音效</strong></h3><p>在MySound类中，有五个QSoundEffect成员变量，在构造函数进行初始化后，只需要在对应位置用QSoundEffect对象的.play()函数就可以实现音效的播放</p><p>MySound类的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MySound::<span class="built_in">MySound</span>(QObject *parent)</span><br><span class="line">    : QObject&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line">    ha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/ha.wav&quot;</span>));</span><br><span class="line">    ha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);  <span class="comment">//循环次数</span></span><br><span class="line">    ha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>); <span class="comment">//音量  0~1之间</span></span><br><span class="line"></span><br><span class="line">    highest_yaha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/highest_yaha.wav&quot;</span>));</span><br><span class="line">    highest_yaha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    highest_yaha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    yaha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/yaha.wav&quot;</span>));</span><br><span class="line">    yaha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    yaha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    wula.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/wuda.wav&quot;</span>));</span><br><span class="line">    wula.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    wula.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line"></span><br><span class="line">    wulayaha.<span class="built_in">setSource</span>(QUrl::<span class="built_in">fromLocalFile</span>(<span class="string">&quot;:/sound/wulayahayahawula.wav&quot;</span>));</span><br><span class="line">    wulayaha.<span class="built_in">setLoopCount</span>(<span class="number">1</span>);</span><br><span class="line">    wulayaha.<span class="built_in">setVolume</span>(<span class="number">0.25f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a><strong>技术亮点</strong></h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a><strong>数据库设计</strong></h3><p>accounts表设计</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105411435.png" alt="image-20240617105411435"></p><p>contacts表设计：</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105418807.png" alt="image-20240617105418807"></p><p>本数据库设计的亮点在于将accounts表的id字段（主键）设定为了 contacts表中user_id字段的外键，同时将On Update和On Delete都设定为了CASCADE,保证了数据的同步。</p><p>通过这样的方式，每一个联系人都用一个user_id字段表明这个联系人属于哪一个特定的用户，即便将所有联系人数据存储在一张表格中，也不会导致混乱。</p><h3 id="云端数据库"><a href="#云端数据库" class="headerlink" title="云端数据库"></a><strong>云端数据库</strong></h3><p>本项目将数据库建立在阿里云的RDS数据库，解决了最终.exe程序的连接问题，使得程序真正成为一个可独立运行的软件。</p><p>无论在什么地方，采用什么设备，只要能够正常联网，用户就可以查询到自己账户里的联系人信息。</p><p>部分用户展示（表明程序可正常运行）</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105450395.png" alt="image-20240617105450395"></p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105457358.png" alt="image-20240617105457358"></p><h3 id="右键菜单的实现："><a href="#右键菜单的实现：" class="headerlink" title="右键菜单的实现："></a><strong>右键菜单的实现：</strong></h3><p>本项目在头像处和主界面TableView处都使用了右键菜单，这里以主界面的实现方式进行讲解：</p><p>在Mainfunc的set_Menu函数中，首先调用QTableView的setContextMenuPolicy(Qt::CustomContextMenu)函数</p><p>使右键能够发送customContextMenuRequested信号</p><p>接着为QMenu对象添加两个QAction对象，然后将customContextMenuRequested信号与槽函数Menu_Slot连接</p><p>以及将两个QAction对象triggered信号与Modify_func对象中对应的对应槽函数连接（这两个槽函数在上文进行过讲解）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mainfunc::set_menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//右键发送customContextMenuRequested 信号</span></span><br><span class="line">    ui-&gt;contact_table-&gt;<span class="built_in">setContextMenuPolicy</span>(Qt::CustomContextMenu);</span><br><span class="line">    <span class="keyword">this</span>-&gt;tableviewMenu = <span class="keyword">new</span> <span class="built_in">QMenu</span>( ui-&gt;contact_table); <span class="comment">// menu的父类是tableview 对象</span></span><br><span class="line"></span><br><span class="line">    Action1 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;查看&quot;</span>, ui-&gt;contact_table);</span><br><span class="line">    Action2 = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="string">&quot;删除&quot;</span>, ui-&gt;contact_table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单项</span></span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">addAction</span>(Action1);</span><br><span class="line">    tableviewMenu-&gt;<span class="built_in">addAction</span>(Action2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>( ui-&gt;contact_table,&amp;QTableView::customContextMenuRequested,<span class="keyword">this</span>,&amp;Mainfunc::Menu_Slot);</span><br><span class="line">    <span class="built_in">connect</span>(Action1, &amp;QAction::triggered,modify_func,&amp;Modify_func::Action1_Slot);</span><br><span class="line">    <span class="built_in">connect</span>(Action2, &amp;QAction::triggered,modify_func,&amp;Modify_func::Action2_Slot);</span><br><span class="line"></span><br><span class="line">    modify_func-&gt;user_id=user_id;<span class="comment">//传递user_id</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(modify_func, &amp;Modify_func::delete_ready,<span class="keyword">this</span>,&amp;Mainfunc::show_cot); <span class="comment">//删除成功后，刷新tableview</span></span><br><span class="line">    <span class="built_in">connect</span>(modify_func, &amp;Modify_func::change_ready,<span class="keyword">this</span>,&amp;Mainfunc::show_cot); <span class="comment">//修改成功后，刷新tableview</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Menu_Slot函数中，首先获取鼠标点击位置的索引，并对点击的位置、选取的项目个数进行检验</p><p>只有在表格中的有效数据位置选中单个项目才会唤出右键菜单</p><p>接着将索引以及Mainfunc页面的model进行传递给了Modify_func对象</p><p>方便后续在数据库中通过这些信息进行查询，以更改&#x2F;删除某一特定联系人的数据。  </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收鼠标右键信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mainfunc::Menu_Slot</span><span class="params">(QPoint p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    QModelIndex index = ui-&gt;contact_table-&gt;<span class="built_in">indexAt</span>(p);<span class="comment">//获取鼠标点击位置项的索引</span></span><br><span class="line">    <span class="keyword">if</span>(index.<span class="built_in">isValid</span>())<span class="comment">//检验数据项是否有效，空白处点击无菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action1-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        Action2-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        QItemSelectionModel* selections =  ui-&gt;contact_table-&gt;<span class="built_in">selectionModel</span>();<span class="comment">//获取当前的选择模型</span></span><br><span class="line">        QModelIndexList selected = selections-&gt;<span class="built_in">selectedIndexes</span>();<span class="comment">//返回当前选择的模型索引</span></span><br><span class="line">        <span class="keyword">if</span>(selected.<span class="built_in">count</span>() ==<span class="number">1</span>) <span class="comment">//选择单个项目时</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">//多选，不显示菜单项</span></span><br><span class="line">        &#123;</span><br><span class="line">            Action1-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">            Action2-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先传递数据，再显示菜单</span></span><br><span class="line">        QAbstractItemModel *model =  ui-&gt;contact_table-&gt;<span class="built_in">model</span>(); <span class="comment">// 获取 QTableView 的模型</span></span><br><span class="line">        <span class="comment">//传递当前模型和鼠标位置索引</span></span><br><span class="line">        modify_func-&gt;model=model;</span><br><span class="line">        modify_func-&gt;index=index;</span><br><span class="line"></span><br><span class="line">        sound.wula.<span class="built_in">play</span>();</span><br><span class="line">        tableviewMenu-&gt;<span class="built_in">exec</span>(QCursor::<span class="built_in">pos</span>());<span class="comment">//显示菜单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生日查询功能"><a href="#生日查询功能" class="headerlink" title="生日查询功能"></a><strong>生日查询功能</strong></h3><p>在实现类似查询倒数xx天过生日的人的时候，网上的解决方案经常会存在一个跨年问题，也有很多人提出了自己的解决方案，我在这里也展示一下我自己想出的解决方案，如有错误欢迎指正。</p><p>如果没有发生跨年，DATE_FORMAT(birth,’%m%d’)先截取DATE类型的数据的月份和日期信息</p><p>接着要求这个数据</p><p>BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,’%m%d’) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,’%m%d’)</p><p>其中：day将会被赋值为用户选择的那个天数，表明在当前日期前后各n天</p><p>假如发生了跨年，则改为：</p><p>BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,’%m%d’) AND STR_TO_DATE(‘12.31’,’%m.%d’)</p><p>OR</p><p>BETWEEN STR_TO_DATE(‘1.1’,’%m.%d’) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,’%m%d’)</p><p>这表明将查询的日期限定在当前日期减去n天后的日期到12.31<strong>或</strong>1.1到当前日期加上n天后的日期</p><p>可以发现，无论是向去年跨一年还是向明年跨一年，这段代码都可以实现查询</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sound.wula.play();</span><br><span class="line">   QString days <span class="operator">=</span> ui<span class="operator">-</span><span class="operator">&gt;</span>spinBox_3<span class="operator">-</span><span class="operator">&gt;</span>text();</span><br><span class="line">   <span class="type">int</span> daysInt <span class="operator">=</span> days.toInt();</span><br><span class="line">   <span class="operator">/</span><span class="operator">/</span>往前后各数daysInt天</span><br><span class="line">   QSqlQuery query;</span><br><span class="line">   QDate currentDate <span class="operator">=</span> QDate::currentDate();</span><br><span class="line">   QDate past_searchDate <span class="operator">=</span> currentDate.addDays(<span class="operator">-</span>daysInt);</span><br><span class="line">   QDate future_searchDate <span class="operator">=</span> currentDate.addDays(daysInt);</span><br><span class="line">   if(past_searchDate.year()<span class="operator">=</span><span class="operator">=</span>currentDate.year()<span class="operator">&amp;&amp;</span>future_searchDate.year()<span class="operator">=</span><span class="operator">=</span>currentDate.year())&#123;</span><br><span class="line">       query.prepare(&quot;SELECT name, birth, phone, email, type FROM contacts WHERE user_id = :user_id&quot;</span><br><span class="line">                     &quot;AND &quot;</span><br><span class="line">                     &quot;(DATE_FORMAT(birth,&#x27;%m%d&#x27;) BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,&#x27;%m%d&#x27;) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,&#x27;%m%d&#x27;))&quot;);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="operator">/</span><span class="operator">/</span>跨年</span><br><span class="line">   &#123;</span><br><span class="line">       query.prepare(&quot;SELECT name, birth, phone, email, type FROM contacts WHERE user_id = :user_id&quot;</span><br><span class="line">                     &quot;AND &quot;</span><br><span class="line">                     &quot;((DATE_FORMAT(birth,&#x27;%m%d&#x27;) BETWEEN DATE_FORMAT(CURDATE()-INTERVAL :days DAY,&#x27;%m%d&#x27;) AND STR_TO_DATE(&#x27;12.31&#x27;,&#x27;%m.%d&#x27;)))&quot;</span><br><span class="line">                     &quot;OR&quot;</span><br><span class="line">                     &quot;(DATE_FORMAT(birth,&#x27;%m%d&#x27;) BETWEEN STR_TO_DATE(&#x27;1.1&#x27;,&#x27;%m.%d&#x27;) AND DATE_FORMAT(CURDATE()+INTERVAL :days DAY,&#x27;%m%d&#x27;))&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   query.bindValue(&quot;:user_id&quot;, this<span class="operator">-</span><span class="operator">&gt;</span>user_id);</span><br><span class="line">   query.bindValue(&quot;:days&quot;, daysInt);</span><br><span class="line">   query.exec();</span><br></pre></td></tr></table></figure><h2 id="难点攻破"><a href="#难点攻破" class="headerlink" title="难点攻破"></a><strong>难点攻破</strong></h2><p>&nbsp;</p><h3 id="缺少MySQL驱动的问题"><a href="#缺少MySQL驱动的问题" class="headerlink" title="缺少MySQL驱动的问题"></a><strong>缺少MySQL驱动的问题</strong></h3><p>在QT中使用MySQL的人可能会遭遇一个普遍的问题：QT没有提供MySQL的驱动</p><p>解决方法：先在MySQL的安装路径中找到libmysql.dll和libmysql.lib这两个文件</p><p>接着将这两个文件复制到qt的编译器安装路径（我用的是mingw）的bin文件夹中</p><p>下一步需要利用qt编译qsqlmysql.dll以及qsqlmysqld.dll这两个文件，并将它们添加到qt的编译器安装路径的\plugins\sqldrivers文件夹中，但是这一步较为繁琐，详细流程可以参考：</p><p><a href="https://blog.csdn.net/m0_46273020/article/details/104256219">关于解决Qt MySql没有QMYSQL驱动文件的问题详解_qt可发现的驱动没有qmysql-CSDN博客</a></p><p>我的解决方案是在github上找到了别人编译好的.dll文件，github链接为：</p><p><a href="https://github.com/thecodemonkey86/qt_mysql_driver">thecodemonkey86&#x2F;qt_mysql_driver: Typical symptom: QMYSQL driver not loaded. Solution: get pre-built Qt SQL driver plug-in required to establish a connection to MySQL &#x2F; MariaDB using Qt. Download qsqlmysql.dll binaries built from official Qt source code (github.com)</a></p><p>注意这里新版本的文件可以对版本兼容，但是添加老版本的库文件在新版本无法正常运行</p><p>最好下载对应qt版本的库文件。</p><h3 id="生日查询功能的简洁实现"><a href="#生日查询功能的简洁实现" class="headerlink" title="生日查询功能的简洁实现"></a><strong>生日查询功能的简洁实现</strong></h3><p>在实现年-月-日查询的时候，我希望“0”作为一个默认值，代表所有，这导致一个问题，假如我通过if语句去判断三个QspinBox</p><p>的数值是否为0，根据排列组合，共有8种可能情况，这样写会导致代码的臃肿。</p><p>最终我利用了Qstring可以直接相加的特性，大大简化了代码，代码如下：</p><p>首先获取用户输入，判定每个QspinBox数值是否为0，如果不为0，就加上AND …sql语句</p><p>同样的，在执行查询之前，也判定各个数值是否为0，如果不为0，就对对应的占位符进行赋值</p><p>这样就用较短的代码实现了查询功能。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (year != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        whereClause += <span class="string">&quot; AND YEAR(birth) = :year&quot;</span>;</span><br><span class="line">        yearValue = year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (month != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        whereClause += <span class="string">&quot; AND MONTH(birth) = :month&quot;</span>;</span><br><span class="line">        monthValue = month;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (day != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        whereClause += <span class="string">&quot; AND DAY(birth) = :day&quot;</span>;</span><br><span class="line">        dayValue = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QSqlQuery query;</span><br><span class="line">    query.<span class="built_in">prepare</span>(<span class="string">&quot;SELECT name, birth, phone, email, type &quot;</span></span><br><span class="line">                  <span class="string">&quot;FROM contacts &quot;</span></span><br><span class="line">                  + whereClause);</span><br><span class="line">    query.<span class="built_in">bindValue</span>(<span class="string">&quot;:user_id&quot;</span>, <span class="keyword">this</span>-&gt;user_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (year != <span class="string">&quot;0&quot;</span>) query.<span class="built_in">bindValue</span>(<span class="string">&quot;:year&quot;</span>, yearValue);</span><br><span class="line">    <span class="keyword">if</span> (month != <span class="string">&quot;0&quot;</span>) query.<span class="built_in">bindValue</span>(<span class="string">&quot;:month&quot;</span>, monthValue);</span><br><span class="line">    <span class="keyword">if</span> (day != <span class="string">&quot;0&quot;</span>) query.<span class="built_in">bindValue</span>(<span class="string">&quot;:day&quot;</span>, dayValue);</span><br><span class="line"></span><br><span class="line">    query.<span class="built_in">exec</span>();</span><br></pre></td></tr></table></figure><h3 id="exe程序无法运行问题"><a href="#exe程序无法运行问题" class="headerlink" title=".exe程序无法运行问题"></a><strong>.exe程序无法运行问题</strong></h3><p>在将本程序打包为.exe程序供其他人使用的时候，遭遇了一系列问题，但最后都一一解决，接下来我将逐个介绍。</p><h4 id="Cannot-load-lilbrary-Qt6Core-dil问题"><a href="#Cannot-load-lilbrary-Qt6Core-dil问题" class="headerlink" title="Cannot load lilbrary Qt6Core.dil问题"></a>Cannot load lilbrary Qt6Core.dil问题</h4><p>在一开始将.exe发送给其他人时，他们反映会出现Cannot load lilbrary Qt6Core.dil的报错</p><p>这里我已经通过windeployqt 的方式添加了必要的文件，在文件夹中也的确有Qt6Core.dil这一个文件</p><p>查阅资料发现可能是因为缺少libgcc_s_seh-1.dll，libwinpthread.dll，libstdc++-6.dll这三个动态库，于是在编译器（mingw）的bin目录下拷贝这三个动态库，再次打包，发现报错仍然存在。</p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105807295.png" alt="image-20240617105807295" style="zoom:50%;"><p>进一步查阅资料，发现需要将编译器的bin目录添加到系统的环境变量中，添加后再次打包，程序在其他电脑上终于可以正常运行。</p><p><img src="/2024/06/17/%E4%B9%8C%E8%90%A8%E5%A5%87%E9%80%9A%E8%AE%AF%E5%BD%95%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-1/image-20240617105827180-1718594953596-72.png" alt="image-20240617105827180"></p><h4 id="无法连接数据库问题"><a href="#无法连接数据库问题" class="headerlink" title="无法连接数据库问题"></a>无法连接数据库问题</h4><p>程序可以运行后，我的舍友尝试使用，点击按钮却没有响应，经排查，是因为没有连接上数据库</p><p>一开始我的数据库建立在本地，即便开放了防火墙，开放数据库的权限（允许任意ip地址的用户登录数据库账号）</p><p>其他人也很难连接到我本地的数据库，借用他的电脑进行测试，发现无法Ping通，而随后我用将ip改为我的阿里云ECS服务器，发现可以Ping通，于是决定将数据库建立在云端。</p><p>一开始我是使用ECS建立数据库，但是在Linux系统中运行MySQL的时候一直出现mysql: error while loading shared libraries: libssl.so.10的问题，于是决定采用RDS数据库服务。</p><p>通过在建立账号-开放权限-用workbench连接建立数据库-设置白名单允许所有ip地址的用户连接</p><p>等一系列操作后，用户终于可以正确连接我的数据库，exe程序也终于可以正常运行。</p><h2 id="结语-源代码获取"><a href="#结语-源代码获取" class="headerlink" title="结语&#x2F;源代码获取"></a>结语&#x2F;源代码获取</h2><p>本项目在11周开始开发，到14周周末基本开发完成，历时接近一个月。</p><p>在这个过程中，我学习了QT的使用，基本的SQL语法，学习了数据库的各种相关操作。</p><p>同时，第一次做一个这么完整的项目，也让我对真正的开发工作有了全新的理解，在开发过程中，各个头文件采取怎样的包含关系，如何做好内存管理，如何减少重复的代码量，如何对相关功能代码进行正确的封装，如何增加代码的可读性，这些都是我在之前的学习过程中从未遇到的挑战，也是我在此项目开发过程中收获的宝贵经验。</p><p>在开发过程中，我也遇到过一个又一个难题，从一开始的QT缺少MySQL驱动，到如何传递user_id保证联系人与账户对应，再到如何实现插入图片的功能，以及如何对图片大小进行压缩（有一次我插入一张画质较高的照片直接导致程序崩溃），到如何实现生日查询、如何发送邮件、如何实现右键菜单、如何进行页面美化以及如何正确打包以便发给其他用户使用，最终这些问题都通过在网上查找各种教程顺利解决，这一过程很好地锻炼了我的解决问题能力以及自学能力，为日后更加深入的学习打好了基础。</p><p>最后，感谢老师细致的教学，感谢所有帮助我测试程序、改进功能的朋友们，也感谢那个辛勤付出的自己。</p><p>本项目源代码已上传github，链接：<a href="https://github.com/HOWILLMAKEIT/UsagiContacts">HOWILLMAKEIT&#x2F;UsagiContacts: C++大作业之乌萨奇通讯录 (github.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HELLO WORLD</title>
      <link href="/2024/06/13/hello-world-1/"/>
      <url>/2024/06/13/hello-world-1/</url>
      
        <content type="html"><![CDATA[<p>我终于部署好了博客网站，欢迎大家多来我的网站。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
